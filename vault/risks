#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
risks_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks - Identity creation and management tool\n"
    echo

  else
    printf "risks - Identity creation and management tool\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks [command]\n"
  printf "  risks [command] --help | -h\n"
  printf "  risks --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  hush      Manage the hush partition mount points and read/write permissions"
  echo "  format    Setup drives for either hush or backup partitions"
  echo "  new       Create new identities, data stores or backups"
  echo "  open      Open an identity or some of its associated data stores"
  echo "  close     Close an identity or some of its associated data stores"
  echo "  list      Show currently open data stores"
  echo "  slam      Close all active identities and unmount hush partition"
  echo "  gpgpass   Copy the identity GPG passphrase to the clipboard"
  echo "  kv        Manage the small key=value store used by other commands/functions"
  echo "  load      Copy some resource to a VM where to use it (completed)"
  echo "  save      Move some data coming from another VM to a (tomb) directory"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  SDCARD_ENC_PART"
    printf "    Device file path to the hush partition\n"
    printf "    Default: /dev/hush\n"
    echo

    # :environment_variable.usage
    echo "  SDCARD_ENC_PART_MAPPER"
    printf "    Name of LUKS mapper to hush partition\n"
    printf "    Default: hush\n"
    echo

    # :environment_variable.usage
    echo "  SDCARD_QUIET"
    printf "    Enable sound when hush device is mounted (0: enabled, 1: disabled), default\n    is 0/enabled.\n"
    printf "    Default: 0\n"
    echo

    # :environment_variable.usage
    echo "  HUSHDIR"
    printf "    Directory mount point for the hush device\n"
    printf "    Default: ~/.hush\n"
    echo

    # :environment_variable.usage
    echo "  GRAVEYARD"
    printf "    Directory where to store tomb files\n"
    printf "    Default: ~/.graveyard\n"
    echo

  fi
}

# :command.usage
risks_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush - Manage the hush partition mount points and read/write permissions\n"
    echo

  else
    printf "risks hush - Manage the hush partition mount points and read/write permissions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks hush [command]\n"
  printf "  risks hush [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  mount    Mount the hush drive"
  echo "  rw       Set read-write permissions on the hush partition"
  echo "  ro       Set read-only permissions on the hush partition"
  echo "  umount   Unmount the hush drive"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_mount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush mount - Mount the hush drive\n"
    echo

  else
    printf "risks hush mount - Mount the hush drive\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks hush mount\n"
  printf "  risks hush mount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_rw_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush rw - Set read-write permissions on the hush partition\n"
    echo

  else
    printf "risks hush rw - Set read-write permissions on the hush partition\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks hush rw\n"
  printf "  risks hush rw --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_ro_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush ro - Set read-only permissions on the hush partition\n"
    echo

  else
    printf "risks hush ro - Set read-only permissions on the hush partition\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks hush ro\n"
  printf "  risks hush ro --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_umount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush umount - Unmount the hush drive\n"
    echo

  else
    printf "risks hush umount - Unmount the hush drive\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks hush umount\n"
  printf "  risks hush umount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_format_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks format - Setup drives for either hush or backup partitions\n"
    echo

  else
    printf "risks format - Setup drives for either hush or backup partitions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks format [command]\n"
  printf "  risks format [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  sdcard   Device storing identity secrets (GPG/coffin/age keys)"
  echo "  backup   Device storing backup data (identities' secrets/data, hush.img, etc)"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_format_sdcard_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks format sdcard - Device storing identity secrets (GPG/coffin/age keys)\n"
    echo

  else
    printf "risks format sdcard - Device storing identity secrets (GPG/coffin/age keys)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks format sdcard DEVICE [options]\n"
  printf "  risks format sdcard --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DEVICE"
    printf "    Device file of the sdcard drive (must be a whole drive without a partition\n    number, eg. /dev/sda)\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  format sdcard /dev/xvdi\n"
    echo

  fi
}

# :command.usage
risks_format_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks format backup - Device storing backup data (identities' secrets/data, hush.img, etc)\n"
    echo

  else
    printf "risks format backup - Device storing backup data (identities' secrets/data, hush.img, etc)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks format backup DEVICE [options]\n"
  printf "  risks format backup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DEVICE"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  format backup /dev/xvdi\n"
    echo

  fi
}

# :command.usage
risks_new_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks new - Create new identities, data stores or backups\n"
    echo

  else
    printf "risks new - Create new identities, data stores or backups\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks new [command]\n"
  printf "  risks new [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  identity   Create a new GPG identity, with SSH/password-store/Signal and associated tombs"
  echo "  tomb       Create a new tomb"
  echo "  backup     Create a new backup with all the data currenly available in the hush drive and the graveyard"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_new_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks new identity - Create a new GPG identity, with SSH/password-store/Signal and associated tombs\n"
    echo

  else
    printf "risks new identity - Create a new GPG identity, with SSH/password-store/Signal and associated tombs\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
  printf "  risks new identity --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --log, -l"
    printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
    echo

    # :flag.usage
    echo "  --log-file, -f LOGFILE"
    printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
    printf "    Default: default\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  NAME"
    printf "    Alias/nym/name to use for the identity (can include spaces if full name, but\n    use quotes accordingly)\n"
    echo

    # :argument.usage
    echo "  EMAIL"
    printf "    Email address to use for the GPG identity\n"
    echo

    # :argument.usage
    echo "  EXPIRY_DATE"
    printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
    echo

    # :argument.usage
    echo "  BACKUP_DEVICE"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  new identity 'John Doe' john.doe@mail.com '1 year' /dev/xvdj\n"
    echo

  fi
}

# :command.usage
risks_new_tomb_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks new tomb - Create a new tomb\n"
    echo

  else
    printf "risks new tomb - Create a new tomb\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
  printf "  risks new tomb --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --log, -l"
    printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
    echo

    # :flag.usage
    echo "  --log-file, -f LOGFILE"
    printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
    printf "    Default: default\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  TOMB_NAME"
    printf "    Name/label to use for the tomb\n"
    echo

    # :argument.usage
    echo "  SIZE"
    printf "    Size (in MB) of the tomb\n"
    echo

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity for which to create the tomb. Optional: the active identity is used\n    if no identity is specified\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  new tomb Data 100 john_doe\n"
    echo

  fi
}

# :command.usage
risks_new_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks new backup - Create a new backup with all the data currenly available in the hush drive and the graveyard\n"
    echo

  else
    printf "risks new backup - Create a new backup with all the data currenly available in the hush drive and the graveyard\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks new backup DEVICE [options]\n"
  printf "  risks new backup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DEVICE"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  new backup /dev/xvdj\n"
    echo

  fi
}

# :command.usage
risks_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks open - Open an identity or some of its associated data stores\n"
    echo

  else
    printf "risks open - Open an identity or some of its associated data stores\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks open STORE [IDENTITY] [options]\n"
  printf "  risks open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --log, -l"
    printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
    echo

    # :flag.usage
    echo "  --log-file, -f LOGFILE"
    printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
    printf "    Default: default\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  STORE"
    printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to open\n"
    echo

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity owning the store. Optional only if a the store to open is a tomb\n    and an identity is active.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  open identity john_doe       # Opens gpg coffin and mgmt/pass/ssh/signal tombs\n"
    printf "  open gpg john_doe            # Opens the GPG keyring for identity 'john_doe'\n"
    printf "  open ssh                     # Opens the ssh tomb for the active identity\n"
    printf "  open pass [identity]         # Opens the password-store for active identity\n"
    echo

  fi
}

# :command.usage
risks_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks close - Close an identity or some of its associated data stores\n"
    echo

  else
    printf "risks close - Close an identity or some of its associated data stores\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks close STORE [IDENTITY] [options]\n"
  printf "  risks close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --log, -l"
    printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
    echo

    # :flag.usage
    echo "  --log-file, -f LOGFILE"
    printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
    printf "    Default: default\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  STORE"
    printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to close\n"
    echo

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity owning the store. Optional only if a the store to close is a tomb\n    and an identity is active.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  close identity john_doe      # Closes gpg coffin/all tombs for 'john_doe'\n"
    printf "  close identity               # Closes gpg coffin/all tombs for active identity\n"
    printf "  close pass                   # Closes password-store tomb for active identity\n"
    echo

  fi
}

# :command.usage
risks_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks list - Show currently open data stores\n"
    echo

  else
    printf "risks list - Show currently open data stores\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks list STORE\n"
  printf "  risks list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  STORE"
    printf "    Datastore types to list\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  list coffins         # Lists open GPG coffins\n"
    printf "  list tombs           # Lists open tombs\n"
    echo

  fi
}

# :command.usage
risks_slam_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks slam - Close all active identities and unmount hush partition\n"
    echo

  else
    printf "risks slam - Close all active identities and unmount hush partition\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks slam [options]\n"
  printf "  risks slam --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

  fi
}

# :command.usage
risks_gpgpass_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpgpass - Copy the identity GPG passphrase to the clipboard\n"
    echo

  else
    printf "risks gpgpass - Copy the identity GPG passphrase to the clipboard\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks gpgpass [IDENTITY]\n"
  printf "  risks gpgpass --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity for which to copy the GPG passphrase. Optional if an identity is\n    active.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  gpgpass john_doe         # Copy john_doe's GPG key passphrase\n"
    printf "  gpgpass                  # Copy the current identity's GPG key passphrase\n"
    echo

  fi
}

# :command.usage
risks_kv_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv - Manage the small key=value store used by other commands/functions\n"
    echo

  else
    printf "risks kv - Manage the small key=value store used by other commands/functions\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv [command]\n"
  printf "  risks kv [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  set     Set a variable to a value"
  echo "  get     Get the value of a variable"
  echo "  unset   Unset an existing variable"
  echo "  list    List all key=value pairs in the store"
  echo "  clean   Delete all key=value pairs in the store"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_kv_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv set - Set a variable to a value\n"
    echo

  else
    printf "risks kv set - Set a variable to a value\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv set KEY VALUE\n"
  printf "  risks kv set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    echo "  VALUE"
    printf "    Value to assign to the key\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  set signalVM MySignalVM      # Sets the key 'signalVM' to 'mySignalVM' in the\n  store\n"
    echo

  fi
}

# :command.usage
risks_kv_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv get - Get the value of a variable\n"
    echo

  else
    printf "risks kv get - Get the value of a variable\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv get KEY\n"
  printf "  risks kv get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to show\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  get signalVM              # Prints the value of the key 'signalVM'\n"
    echo

  fi
}

# :command.usage
risks_kv_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv unset - Unset an existing variable\n"
    echo

  else
    printf "risks kv unset - Unset an existing variable\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv unset KEY\n"
  printf "  risks kv unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to delete/unset\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  unset signalVM            # Deletes the key 'signalVM' in the key-value store\n"
    echo

  fi
}

# :command.usage
risks_kv_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv list - List all key=value pairs in the store\n"
    echo

  else
    printf "risks kv list - List all key=value pairs in the store\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv list\n"
  printf "  risks kv list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_kv_clean_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv clean - Delete all key=value pairs in the store\n"
    echo

  else
    printf "risks kv clean - Delete all key=value pairs in the store\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks kv clean\n"
  printf "  risks kv clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_load_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks load - Copy some resource to a VM where to use it (completed)\n"
    echo

  else
    printf "risks load - Copy some resource to a VM where to use it (completed)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks load\n"
  printf "  risks load --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
    echo

  else
    printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risks save\n"
  printf "  risks save --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/coffin.sh

# Generates, setup and formats a LUKS partition to be used as a coffin identity files
gen_coffin()

{
    local IDENTITY="$1"

    local pass="$2"

    # Filenames
    local key_filename=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg.key" "$pass")
    local key_file="${HUSH_DIR}/${key_filename}"
    local coffin_filename=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg.coffin" "$pass")
    local coffin_file="${GRAVEYARD}/${coffin_filename}"
    local coffin_name=$(_encrypt_filename ${IDENTITY} "coffin-${IDENTITY}-gpg" "$pass")
    local identity_fs=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg" "$pass")

    _verbose "coffin" "Generating coffin key (compatible with QRCode printing)"
    pwgen -y -s -C 64 > ${key_file} || _failure "coffin" "Failed to generate coffin key"
    _verbose "coffin" "Protecting against deletions"
    sudo chattr +i ${key_file}
    _verbose "coffin" "Testing immutability of key file"
    lsattr ${HUSH_DIR}
    echo
    _verbose "coffin" "Output should look like (filename is encrypted):"
    echo
    echo "—-i———e—- /home/user/.hush/JRklfdjklb334blkfd"
    echo

    _verbose "coffin" "Creating the coffin container (50MB)"
    if [[ ! -d ${GRAVEYARD} ]]; then
            _verbose "coffin" "Creating directory ${GRAVEYARD}"
            mkdir -p ${GRAVEYARD}
    fi
    dd if=/dev/urandom of=${coffin_file} bs=1M count=50
    _verbose "coffin" "Laying the coffin inside the container"
    sudo cryptsetup -v -q --cipher aes-xts-plain64 --master-key-file ${key_file} \
            --key-size 512 --hash sha512 --iter-time 5000 --use-random \
            luksFormat ${coffin_file} ${key_file} \
            || _failure "coffin" "Failed to lay setup and format the coffin LUKS filesystem"
    _verbose "coffin" "Testing the coffin"
    sudo cryptsetup luksDump ${coffin_file} || _failure "coffin" "Failed to dump coffin LUKS filesystem"
    echo
    _warning "coffin" "Normally, we should see the UUID of the coffin, and only key configured for it" -b
    echo


    _success "coffin" "5) Setup"
    _verbose "coffin" "Opening the coffin for setup"
    sudo cryptsetup open --type luks ${coffin_file} ${coffin_name} --key-file ${key_file} \
            || _failure "coffin" "Failed to open the coffin LUKS filesystem"

    _verbose "coffin" "Testing coffin status"
    sudo cryptsetup status ${coffin_name} || _warning "coffin" "Failed to get status of coffin LUKS filesystem"
    echo

    _verbose "coffin" "Formatting the coffin filesystem (ext4)"
    sudo mkfs.ext4 -m 0 -L ${identity_fs} /dev/mapper/${coffin_name} \
            || _failure "coffin" "Failed to make ext4 filesystem on coffin partition"
}

# open_coffin requires both an identity name and its corresponding passphrase
open_coffin()
{
	local IDENTITY="${1}"
    local pass="${2}"

    local key_filename=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg.key" "$pass")
    local key_file="${HUSH_DIR}/${key_filename}"
    local coffin_filename=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg.coffin" "$pass")
    local coffin_file="${GRAVEYARD}/${coffin_filename}"
    local mapper=$(_encrypt_filename ${IDENTITY} "coffin-${IDENTITY}-gpg" "$pass")

	local mount_dir="${HOME}/.gnupg"

	if [[ ! -f "${coffin_file}" ]]; then
		echo "I'm looking for ${coffin_file} but no coffin file found in ${GRAVEYARD}"
		exit 1
	fi

	if is_luks_mounted "/dev/mapper/${mapper}" ; then
		echo "Coffin file ${coffin_file} is already open and mounted"
		return 0
	fi

	if ! is_luks_open ${mapper}; then
		if ! sudo cryptsetup open --type luks ${coffin_file} ${mapper} --key-file ${key_file} ; then
			echo "I can not open the coffin file ${coffin_file}"
			exit 1
		fi
	fi

	mkdir -p ${mount_dir} &> /dev/null

	if ! sudo mount -o rw,user /dev/mapper/${mapper} ${mount_dir} ; then
		echo "Coffin file ${coffin_file} can not be mounted on ${mount_dir}"
		exit 1
	fi

	sudo chown ${USER} ${mount_dir}
	sudo chmod 0700 ${mount_dir}
    _set_identity ${IDENTITY} # And set the active identity file
	_verbose "identity" "Coffin ${coffin_file} has been opened in ${mount_dir}"
}

close_coffin()
{
    local IDENTITY="${1}"
    local pass="${2}"

    local coffin_filename=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg.coffin" "$pass")
    local coffin_file="${GRAVEYARD}/${coffin_filename}"
    local mapper=$(_encrypt_filename ${IDENTITY} "coffin-${IDENTITY}-gpg" "$pass")

	local mount_dir="${HOME}/.gnupg"

    # Gpg-agent is an asshole spawning thousands of processes
    # without anyone to ask for them.... security they said
    gpgconf --kill gpg-agent

	if is_luks_mounted "/dev/mapper/${mapper}" ; then
		if ! sudo umount ${mount_dir} ; then
			echo "Coffin file ${coffin_file} can not be umounted from ${mount_dir}"
			exit 1
		fi
	fi

	if is_luks_open ${mapper}; then
		if ! sudo cryptsetup close /dev/mapper/${mapper} ; then
			echo "Coffin file ${coffin_file} can not be closed"
			exit 1
		fi
	else
		echo "Coffin file ${coffin_file} is already closed"
		return 0
	fi

    _set_identity '' # An empty  identity will trigger a wiping of the file

	_verbose "identity" "Coffin file ${coffin_file} has been closed"
}

list_coffins()
{
	local coffins_num=0

	if ls -1 /dev/mapper/coffin-* &> /dev/null; then
		local coffins=$(ls -1 /dev/mapper/coffin-*| awk -F- {'print $2'})
		local coffins_num=$(echo ${coffins} | wc -l)
	fi

	if [[ ${coffins_num} -gt 0 ]]; then
		_message "risks" "Coffins currently open:"
		echo $(echo ${coffins} | xargs)
	fi
}

# src/lib/data.sh

# Loads copies some data needed by some tool on another VM. Generally a script
# in the said VM should be invoked so as to move to the date to its final destination.
load()
{
    # Parameters
	local IDENTITY="${1}"
    local RESOURCE="${2}"   # Resource is a tomb file (root directory) in ~/.tomb
    local DEST_VM="${3}"

    # Open the related tomb for the tool

    open_tomb ${RESOURCE} ${IDENTITY} --silent || _failure "${RESOURCE}" "Failed to open tomb"

    # Get the source directory, and copy the files to the VM
    _message "risks" "Loading data in tomb $RESOURCE to VM ${DEST_VM}"
	local source_dir="${HOME}/.tomb/${RESOURCE}"
    qvm-copy-to-vm "${DEST_VM}" "${source_dir}/"'*'
}

# Repatriate all data coming from a given VM, but not using this VM name as a parameter.
# Generally, the argument is something like "signal", for which this program knows that
# the data is in "msg" VM, if not otherwise specified by the 3rd argument (optional)
save ()

{
	local IDENTITY="${1}"
    local SOURCE_VM="${2}"
	local RESOURCE="${3}"

    # Make the source directory

    # Don't do anything if the directory does not exist
    local source_dir="${HOME}/QubesIncoming/${SOURCE_VM}"
    if [[ ! -d $source_dir ]]; then
        _failure "${RESOURCE}" "No QubesIncoming directory found for ${SOURCE_VM}"
    fi

    # Open the related tomb for the tool

    open_tomb ${RESOURCE} ${IDENTITY} --silent || _failure "${RESOURCE}" "Failed to open tomb"

    # And make the destination directory
	local dest_dir="${HOME}/.tomb/${RESOURCE}"

    # Or move the data from the directory to the tomb directory
    _message "risks" "Moving data to tomb ${RESOURCE} directory"
    mv "${source_dir}/"'*' "${dest_dir}"
}

# src/lib/gpg.sh

# Create a RAMDisk and setup the GPG directory in it, with configuration files
init_gpg()
{
    _verbose 'ramdisk' 'Creating directory & setting permissions'
    rm -fR ${RAMDISK}
    mkdir ${RAMDISK}
    mount -t tmpfs -o size=10m ramdisk ${RAMDISK} || _failure "Failed to mount tmp fs on ramdisk"
    $s chown ${USER} ${RAMDISK} || _failure "Failed to set ownership to ${RAMDISK}"
    $s chmod 0700 ${RAMDISK} || _failure "Failed to change mod 0700 to ${RAMDISK}"

    _message "ramdisk" "Testing"
    _verbose "$(mount | grep ramdisk)"
    _verbose "ramdisk" "Previous command should look like this: \n\n\
        ramdisk on /home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n\
        ramdisk on /rw/home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n"

    _verbose "ramdisk" "Testing creation/deletion of files"
    touch "${RAMDISK}/delme" && rm "${RAMDISK}/delme" || _failure "ramdisk" "Failed to test write file ${1}"

    # Configuration files
    _verbose "gpg" "Writing default GPG configuration file"
    cat >"${RAMDISK}/gpg.conf" <<EOF
# Avoid information leaked
no-emit-version
no-comments
export-options export-minimal

# Options for keys listing
keyid-format 0xlong
with-fingerprint
with-keygrip
with-subkey-fingerprint

# Displays the validity of the keys
list-options show-uid-validity
verify-options show-uid-validity

# Limits preferred algorithms
personal-cipher-preferences AES256
personal-digest-preferences SHA512
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed

# Options for asymmetric encryption
cipher-algo AES256
digest-algo SHA512
cert-digest-algo SHA512
compress-algo ZLIB
disable-cipher-algo 3DES
weak-digest SHA1

# Options for symmetric encryption
s2k-cipher-algo AES256
s2k-digest-algo SHA512
s2k-mode 3
s2k-count 65011712
EOF
}

# Create key pairs for a given identity, based on a premade batch file
gen_gpg_keys()
{
    local name="$1"
    local email="$2"
    local expiry="$3"
    local passphrase="$4"

    # Output the identity batch file with values
    _verbose "gpg" "Writing GPG batch file to ramdisk"
    cat >${RAMDISK}/primary_key_unattended <<EOF
%echo Generating EDDSA key (Ed25519 curve)
Key-Type: eddsa

Key-Curve: Ed25519

Key-Usage: sign
Key-Length: 4096
Name-Real: ${name}

Name-Email: ${email}

Expire-Date: 0
Passphrase: ${passphrase}

%commit
%echo done
EOF

    # Generate key and get rid of batch file
    _verbose "gpg" "Generating primary key from batch file"
    gpg --batch --gen-key ${RAMDISK}/primary_key_unattended || _failure "Failed to generate keys from batch file"
    _verbose "gpg" "Deleting batch file"
    wipe -f ${RAMDISK}/primary_key_unattended || _failure "Failed to wipe batch file: contains the identity passphrase"
    _verbose "gpg" "Listing keys:"
    local fingerprint=$(gpg -K ${email} | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')
    _msg "gpg" "Fingerprint: ${fingerprint}"


    _verbose "gpg" "Generating encryption subkey-pair"
    local expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"

    echo "$passphrase" | gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key ${fingerprint} cv25519 encr ${expiry_date} \
            || _failure "Failed to generate encryption subkey-pair"

    _verbose "gpg" "Generating signature subkey-pair"
    echo "$passphrase" | gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key ${fingerprint} ed25519 sign ${expiry_date} \
            || _failure "Failed to generate signature subkey-pair"

    _verbose "gpg" "Generating authentication subkey-pair"
    echo "$passphrase" | gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key ${fingerprint} ed25519 auth ${expiry_date} \
            || _warning "subkeys" "Failed to generate authentication subkey-pair. Continuing still"

    _verbose "gpg" "Directory structure:"
    verbose "gpg" "$(tree ${RAMDISK})"
}

# A rather complete function performing several important, but quite unrelated, tasks:
# - Moves the GPG keyring of an identity into its coffin
# - Checks visually that files are where expected

# - Removes the private keys from the keyring that is used daily
cleanup_gpg_init()
{
    local IDENTITY="$1"
    local email="$2"
    local pass="$3"

    # Filenames
    local TMP_FILENAME=$(_encrypt_filename ${IDENTITY} "${IDENTITY}-gpg" "$pass")
    local TMP="/tmp/${TMP_FILENAME}"
    local coffin_name=$(_encrypt_filename ${IDENTITY} "coffin-${IDENTITY}-gpg" "$pass")

    # Making tmp directory
    _verbose "coffin" "Creating temp directory and mounting coffin"
    mkdir ${TMP}
    sudo mount /dev/mapper/${coffin_name} ${TMP} || _failure "coffin" "Failed to mount coffin partition on ${TMP}"

    $s chown ${USER} ${TMP}
    _verbose "coffin" "Testing coffin filesystem"
    _verbose "$(mount | grep ${TMP_FILENAME})"

    _verbose "coffin" "Copying GPG files in coffin"
    cp -fR ${RAMDISK}/* ${TMP} || _warning "coffin" "Failed to copy one or more files into coffin"
    _verbose "coffin" "Setting GPG files immutable"
    $s chattr +i ${TMP}/private-keys-v1.d/*
    $s chattr +i ${TMP}/openpgp-revocs.d/*
    _verbose "coffin" "Closing coffin"
    sudo umount ${TMP} || _warning "coffin" "Failed to unmount tmp directory ${TMP}"
    sudo cryptsetup close /dev/mapper/${coffin_name} || _failure "coffin" "Failed to close LUKS filesystem for identity"

    # Clearing RAMDisk
    _verbose "ramdisk" "Wiping and unmounting ramdisk"
    sudo wipe -rf ${RAMDISK} || _warning "ramdisk" "Failed to wipe ${RAMDISK} directory"
    sudo umount ${RAMDISK}  || _warning "ramdisk" "Failed to unmount ramdisk ${RAMDISK}"


    _verbose "coffin" "5) Final checks"
    _verbose "coffin" "Checking directory contents"
    _verbose "$(tree ${HUSH_DIR} ${GRAVEYARD})"
    _verbose "coffin" "Should look like this:           \n\n \
    /home/user/.hush                                    \n    \
        ├── fjdri3kff2i4rjkFA (joe-gpg.key)             \n    \
    /home/user/.graveyard                               \n    \
        ├── fejk38RjhfEf13 (joe-gpg.coffin)"

    _verbose "coffin" "Test opening and closing coffin for ${IDENTITY}"
    open_coffin ${IDENTITY} "${pass}"
    close_coffin ${IDENTITY} "${pass}"


    _verbose "gpg" "6) Removing GPG private keys"

    local GPG_TOMB_LABEL_ENC=$(_encrypt_filename ${IDENTITY} "${GPG_TOMB_LABEL}" "$pass")
    local TOMB_SIZE=15
    local fingerprint=$(gpg -K ${email} | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')

    _verbose "gpg" "Creating tomb file for identity ${IDENTITY}"
    new_tomb ${GPG_TOMB_LABEL} ${TOMB_SIZE} "${IDENTITY}" "$pass"
    _verbose "gpg" "Opening tomb file"
    open_tomb ${GPG_TOMB_LABEL} ${IDENTITY}
    local KEYGRIP="$(gpg -K | grep Keygrip | head -n 1 | cut -d= -f 2 | sed 's/ //g').key"
    _verbose "gpg" "Keygrip: ${KEYGRIP}"
    _verbose "gpg" "Copying private data to tomb"
    _verbose "gpg" "Private keys"
    cp ${RAMDISK}/private-keys-v1.d/${KEYGRIP} ${HOME}/.tomb/${GPG_TOMB_LABEL_ENC}/
    _verbose "gpg" "Revocation certificates"
    cp ${RAMDISK}/openpgp-revocs.d/${fingerprint}.rev ${HOME}/.tomb/${GPG_TOMB_LABEL_ENC}/
    _verbose "gpg" "Wiping corresponding files"
    $s chattr -i ${RAMDISK}/private-keys-v1.d/${KEYGRIP}

    wipe -rf ${RAMDISK}/private-keys-v1.d/${KEYGRIP} || _warning "gpg" "Failed to delete master private key from keyring !"
    $s chattr -i ${RAMDISK}/openpgp-revocs.d/${fingerprint}.rev
    wipe -rf ${RAMDISK}/openpgp-revocs.d/${fingerprint}.rev || _warning "gpg" "Failed to delete master key revocation from keyring !"

    _verbose "gpg" "Printing GPG keyring. Should have 'sec#' instead of 'pub'"
    verbose "$(gpg -K)"
    _verbose "gpg" "Closing GPG tomb file"
    close_tomb ${GPG_TOMB_LABEL} ${IDENTITY}
}

# gpgpass essentially wraps a call to spectre with our identity parameters.
# Note that this function cannot fail because of "a wrong password".
#
# If a second, non-nil argument is passed, we print the passphrase:

# this is used when some commands need both the passphrase as an input
# to decrypt something (like files) and the user needs them for GPG prompts
gpgpass ()
{
    local identity="$(_identity_active_or_specified ${1})"

    # Since we did not give any input (master) passphrase to this call,
    # spectre will prompt us for an input one. This input is already known
    # to us, since we have used the same when generating the GPG keys.
    #
    # In addition: this call cannot fail because of "a wrong" passphrase.
    # It will just output something, which will or will not (if actually incorrect)
    # work when pasted in further GPG passphrase prompts.
    local passphrase=$(_passphrase ${identity})

	echo -n "${passphrase}" | xclip -selection clipboard
	( sleep ${GPGPASS_TIMEOUT}; echo -n "" |xclip -selection clipboard;) &

    # Return the passphrase is asked to
    if [[ ! -z ${2} ]]; then
        print "${passphrase}"
    else
        _message "risks" "The passphrase has been saved in clipboard     \n \
        Press CTRL+SHIFT+C to share the clipboard with another qube.     \n \
        Local clipboard will be erased is ${GPGPASS_TIMEOUT} seconds"

    fi
}

# src/lib/hush.sh

# Checks if the "hush partition" has been seen by kernel and returns 0 if true
is_partition_mapper_present()
{
	ls -1 /dev/${SDCARD_ENC_PART_MAPPER} &> /dev/null
}

# Checks if the "hush partition" has been already decrypted and returns 0 if true
is_luks_mapper_present()
{
	ls -1 /dev/mapper/${SDCARD_ENC_PART_MAPPER} &> /dev/null
}

# Checks if the "hush partition" is already mounted and returns 0 if true
is_hush_mounted()
{
	mount | grep "^/dev/mapper/${SDCARD_ENC_PART_MAPPER}" &> /dev/null
}

mount_hush()
{
	global_var_check "SDCARD_ENC_PART"
	global_var_check "SDCARD_ENC_PART_MAPPER"
	global_var_check "HUSH_DIR"
	global_var_check "SDCARD_QUIET"

	if ! is_partition_mapper_present ; then
		_failure "hush" "Device mapper /dev/${SDCARD_ENC_PART_MAPPER} not found."
		_failure "hush" "Be sure you have attached your hush partition."
		exit 1
	fi

	if is_hush_mounted ; then
		_message "hush" "Sdcard already mounted"
		play_sound
		exit 0
	fi

	if ! is_luks_mapper_present ; then
		# decrypts the "hush partition": it will ask for passphrase
		if ! sudo cryptsetup open --type luks ${SDCARD_ENC_PART} ${SDCARD_ENC_PART_MAPPER} ; then
			_failure "hush" "The hush partition ${SDCARD_ENC_PART} can not be decrypted"
			exit 1
		fi
	fi

	# creates the "hush partition" mount point if it doesn't exist
	if [ ! -d ${HUSH_DIR} ]; then
	    mkdir -p ${HUSH_DIR} &> /dev/null
	fi

	# mounts the "hush partition" in read-only mode by default
	if ! sudo mount -o ro /dev/mapper/${SDCARD_ENC_PART_MAPPER} ${HUSH_DIR} ; then
		_failure "hush" "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be mounted on ${HUSH_DIR}"
		exit 1
	fi

	play_sound "plugged"
}

umount_hush()
{
	global_var_check "SDCARD_ENC_PART"
	global_var_check "SDCARD_ENC_PART_MAPPER"
	global_var_check "HUSH_DIR"
	global_var_check "SDCARD_QUIET"

	if ! is_partition_mapper_present ; then
		_failure "risks" "Device mapper /dev/mapper/${SDCARD_ENC_PART_MAPPER} not found.\n \
		Be sure you have attached your hush partition."
	fi

	if is_hush_mounted ; then
		if ! sudo umount -f ${HUSH_DIR} ; then
			_failure "risks" "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be umounted from ${HUSH_DIR}"
		fi
	fi

	if is_luks_mapper_present ; then
		if ! sudo cryptsetup close ${SDCARD_ENC_PART_MAPPER} ; then
			_failure "risks" "SDCARD can not be closed"
		fi
	fi

	play_sound "unplugged"
}

ro_hush()
{
	global_var_check "SDCARD_ENC_PART"
	global_var_check "SDCARD_ENC_PART_MAPPER"
	global_var_check "HUSH_DIR"

	if ! is_hush_mounted ; then
		_failure "risks" "HUSH is not mounted"
	fi

	mount_option="remount,ro"
	if ! sudo mount -o ${mount_option} /dev/mapper/${SDCARD_ENC_PART_MAPPER} ${HUSH_DIR} &> /dev/null ; then
		_failure "risks" "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with read-only permissions"
	fi

}

rw_hush()
{
	global_var_check "SDCARD_ENC_PART"
	global_var_check "SDCARD_ENC_PART_MAPPER"
	global_var_check "HUSH_DIR"

	if ! is_hush_mounted ; then
                _failure "risks" "SDCARD is not mounted"
		exit 1
	fi

	mount_option="remount,rw"

	if ! sudo mount -o ${mount_option} /dev/mapper/${SDCARD_ENC_PART_MAPPER} ${HUSH_DIR} &> /dev/null ; then
		_failure "risks" "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with write permissions"
		exit 1
	fi

	sudo chown ${USER} ${HUSH_DIR}
}

is_luks_open()
{
	ls /dev/mapper/${1} &> /dev/null
}

is_luks_mounted()
{
	mount | grep "^${1}" &> /dev/null
}

# src/lib/identity.sh

# The identity used by RISKS, set when one of the identities

# is unlocked, and reset when this identity is closed.
local RISKS_IDENTITY_FILE="${HOME}/.identity"

# Upon unlocking a given identity, sets the name as an ENV

# variable that we can use in further functions and commands.
# $1 - The name to use. If empty, just resets the identity.
_set_identity ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISKS_IDENTITY_FILE} ]]; then
        wipe -s -f -P 10 ${RISKS_IDENTITY_FILE}
        _verbose "risks" "Identity '${1}' is now inactive, (name file deleted)"
        return
    fi

    # If we don't have a file containing the

    # identity name, populate it.
    if [[ ! -e ${RISKS_IDENTITY_FILE} ]]; then
        print "$1" > ${RISKS_IDENTITY_FILE}
	fi

    _verbose "risks" "Identity '${1}' is now active (name file written)"
}

# Returns 0 if an identity is unlocked, 1 if not.
_identity_active ()

{
    if [[ ! -e ${RISKS_IDENTITY_FILE} ]]; then
        return 1
	fi

    local identity=$(cat ${RISKS_IDENTITY_FILE})
    if [[ -z ${identity} ]]; then
        return 1
    fi

    return 0
}

# Given an argument potentially containing the active identity, checks
# that either an identity is active, or that the argument is not empty.
# $1 - An identity name
# Exits the program if none is specified, or echoes the identity if found.
_identity_active_or_specified ()
{
    if [[ -z ${1} ]] && [[ ! _identity_active ]]; then
        _failure "identity" "Command requires either an identity to be unlocked.\n \
            Please use 'risks open identity <name>' or 'risks open gpg <name>' first."
    fi

    # Print the identity
    if [[ -z ${1} ]]; then
        print "${1}" && return
    fi
    print "$(cat ${RISKS_IDENTITY_FILE})"
}

# src/lib/init.sh

# This file contains additional identity initialization functions.


init_pass ()

{
    local IDENTITY="${1}"

    local email="${2}"
    local passphrase="${3}"

    _verbose "pass" "Creating tomb file for pass"
    new_tomb ${PASS_TOMB_LABEL} 20 "${IDENTITY}" "$passphrase"
    _verbose "pass" "Opening password store"
    open_tomb ${PASS_TOMB_LABEL} ${IDENTITY}
    _verbose "pass" "Initializating password store with recipient ${email}"
    pass init ${email}
    _verbose "pass" "Closing pass tomb file"
    close_tomb ${PASS_TOMB_LABEL} ${IDENTITY}
}

# Creates a default management tomb in which, between others, the key=value store is being kept.
init_mgmt ()
{
    local IDENTITY="${1}"

    local passphrase="${2}"

    _verbose "mgmt" "Creating tomb file for management (key=value store, etc)"
    new_tomb ${MGMT_TOMB_LABEL} 10 "${IDENTITY}" "$passphrase"
    _verbose "mgmt" "Opening management tomb"
    open_tomb ${MGMT_TOMB_LABEL} ${IDENTITY}
    _verbose "mgmt" "Closing management tomb"
    close_tomb ${MGMT_TOMB_LABEL} ${IDENTITY}
}

# store_risks_scripts copies the various vault risks scripts in a special directory in the
# hush partition, along with a small installation scriptlet, so that upon mounting the hush
# somewhere else, the user can quickly install and use the risks on the new machine.
store_risks_scripts ()
{
    local prg_path="$0"

    _verbose "scripts" "Copying risks scripts onto the hush partition"
    mkdir -p "${RISKS_SCRIPTS_INSTALL_PATH}"
    sudo cp "${prg_path}" ${RISKS_SCRIPTS_INSTALL_PATH}
    sudo cp /usr/local/share/zsh/site-functions/_risks ${RISKS_SCRIPTS_INSTALL_PATH}

    cat >${RISKS_SCRIPTS_INSTALL_PATH}/install <<'EOL'
#!/usr/bin/env zsh

local INSTALL_SCRIPT_DIR="${0:a:h}"
local INSTALL_SCRIPT_PATH="$0"
local BINARY_INSTALL_DIR="${HOME}/.local/bin"
local COMPLETIONS_INSTALL_DIR="${HOME}/.local/share/zsh/site-functions"

#
echo "Installing risks script in ${BINARY_INSTALL_DIR}"
if [[ ! -d "${BINARY_INSTALL_DIR}" ]]; then
    mkdir -p "${BINARY_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_PATH}" "${BINARY_INSTALL_DIR}"

#
echo "Installing risks completions in ${COMPLETIONS_INSTALL_DIR}"
if [[ ! -d "${COMPLETIONS_INSTALL_DIR}" ]]; then
    echo "Completions directory does not exist. Creating it."
    echo "You should add it to ${FPATH} and reload your shell"
    mkdir -p "${COMPLETIONS_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_DIR}/_risks" "${COMPLETIONS_INSTALL_DIR}"

echo "Done installing risks scripts."
EOL
}

# src/lib/log.sh

# Messaging function with pretty coloring
function _msg()

{
    local progname="$2"
	local msg="$3"
	local i
	command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	for i in {3..${#}}; do
		msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	done

	local command="print -P"
	local pchars=""
	local pcolor="normal"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"; pchars=" > "; pcolor="yellow"
			;;
		message)
			pchars=" . "; pcolor="white"
			;;
		verbose)
			pchars="[D]"; pcolor="blue"
			;;
		success)
			pchars="(*)"; pcolor="green"
			;;
		warning)
			pchars="[W]"; pcolor="yellow"
			;;
		failure)
			pchars="[E]"; pcolor="red"
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		*)
			pchars="[F]"; pcolor="red"
			msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
			returncode=127
			;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

	if [[ -t $fd ]]; then
	       [[ -n "$progname" ]] && progname="$fg[magenta]$progname$reset_color"
	       [[ -n "$pchars" ]] && pchars="$fg_bold[$pcolor]$pchars$reset_color"
	       msg="$fg[$pcolor]$msg$reset_color"
	fi

	${=command} "${progname}" "${pchars}" "${msg}" >&$fd
	return $returncode
}

function _message() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
	option_is_set -q || _msg "$notice" $@
	return 0
}

function _verbose() {
	option_is_set -D && _msg verbose $@
	return 0
}

function _success() {
	option_is_set -q || _msg success $@
	return 0
}

function _warning() {
	option_is_set -q || _msg warning $@
	return 1
}

function _failure() {
	typeset -i exitcode=${exitv:-1}
	option_is_set -q || _msg failure $@
	# be sure we forget the secrets we were told
	exit $exitcode
}

function _print() {
	option_is_set -q || _msg print $@
	return 0
}

# src/lib/secrets.sh

# _encrypt_filename takes a filename, an identity and a passphrase as input,

# generates an password as output. This password/output is used as the new,

# encrypted name for the file.
# usage: filename=$(_encrypt_filename "$file" "$user" "$pass")
_encrypt_filename ()
{
    local filename="$1"
    local identity="$2"
    local pass="$3"

    # -q            Quiet: just output the password/filename
    # -n            Don't append a newline to the password output
    # -s 0          Read passphrase from stdinput (fd 0)
    # -F n          No config file output
    # -t n          Output a nine characters name, without symbols
    # -u ${user}    User for which to produce the password/name
    local encrypted=$(print "${pass}" | spectre -q -n -s 0 -F n -t n -u ${identity} ${filename})
    print "${encrypted}"
}

# Returns a spectre-generated passphrase, given an identity and an optional password argument.
# - No argument: spectre will prompt for a passphrase, which is essentially creating
#                a new one to be used in later steps.
# - With arg:    spectre uses it to produce an output without any prompt.
#
# usage: password=$(_passphrase "${identity}" ${master_passphrase})
passphrase ()
{
    local identity=${1}
    local master="${2}"

    # The `risks` argument is common to all, since it's not specific to anything.
    local cmd=(spectre -q -n -F n)
    local parameters=(-t K -P 512 -u ${identity} risks)

    if [[ ! -z ${master} ]]; then
        local passphrase=$(print "${master}" | ${cmd} -s 0 ${parameters})
    else
        local passphrase=$(${cmd} ${parameters})
    fi

    print "${passphrase}"
}

# src/lib/ssh.sh

# Generate SSH keypair and sets up scripts for loading multiple keypairs
gen_ssh_keys()
{
    local IDENTITY="$1"
    local email="$2"
    local pass="$3"

    _verbose "SSH" "Creating and opening tomb file for SSH"
    new_tomb ${SSH_TOMB_LABEL} 20 "${IDENTITY}" "$pass"
    open_tomb ${SSH_TOMB_LABEL} ${IDENTITY}

    # Write multi-key loading script
    _verbose "SSH" "Writing multiple SSH-keypairs loading script (ssh-add)"
    cat >"${HOME}/.ssh/ssh-add" <<'EOF'
#!/usr/bin/env bash
#
# Autostart SSH-agent and autoload all private keys in ~/.ssh directory
#
# How to use:
# - Place this scripts in ~/.bashrc. (We did not here, instead we use a .desktop autostart pointing to here).
# - If ssh-agent is not filled by any private keys, passphrase prompts will show up for each private keys
#

# register ssh key
env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
    (umask 077; ssh-agent >| "$env")
    . "$env" >| /dev/null ; }

agent_load_env

# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running
agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
    agent_start
    # this will load all private keys in ~/.ssh directory if agent not running
    find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
    # this will load all private keys in ~/.ssh directory if agent is not filled with any private key
    find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
fi

unset env
EOF
    chmod +x "${HOME}/.ssh/ssh-add" || _warning "SSH" "Failed to make ssh-add custom script executable"

    # Generate keys
    _verbose "SSH" "Generating keys for identity"
    ssh-keygen -t ed25519 -b 4096 -C "${email}" -N "" -f ${HOME}/.ssh/id_ed25519 # No passphrase
    _verbose "SSH" "Making keys immutable"
    $s chattr +i ${HOME}/.ssh/id_ed25519*
    _"SSH" "Closing SSH tomb file"
    close_tomb ${SSH_TOMB_LABEL} ${IDENTITY}
}

# src/lib/store.sh

# print to stderr, red color
kv_echo_err() {
	echo -e "\e[01;31m$@\e[0m" >&2
}

# Usage: kv_validate_key <key>
kv_validate_key() {
	[[ "$1" =~ ^[0-9a-zA-Z._:-]+$  ]]
}

# Usage: kvget <key>
kvget() {
	key="$1"
	kv_validate_key "$key" || {
		_failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$default_kv_user_dir}
	VALUE="$([ -f "$kv_user_dir/$key" ] && cat "$kv_user_dir/$key")"
	echo "$VALUE"

	[ "$VALUE" != "" ]
}

# Usage: kvset <key> [value]

kvset() {
	key="$1"
	value="$2"
	kv_validate_key "$key" || {
        _failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$default_kv_user_dir}
	test -d "$kv_user_dir" || mkdir "$kv_user_dir"
	echo "$value" > "$kv_user_dir/$key"
    _message "kv" "${key} => ${value}"
}

# Usage: kvdel <key>
kvdel() {
	key="$1"
	kv_validate_key "$key" || {
        _failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$default_kv_user_dir}
	test -f "$kv_user_dir/$key" && rm -f "$kv_user_dir/$key"
    _message "kv" "Deleted key '${key}'"
}

# list all key/value pairs to stdout
# Usage: kvlist
kvlist() {
	kv_user_dir=${KV_USER_DIR:-$default_kv_user_dir}
	for i in "$kv_user_dir/"*; do
		if [ -f "$i" ]; then
			key="$(basename "$i")"
			echo "$key" "$(kvget "$key")"
		fi
	done

}

# clear all key/value pairs in database
# Usage: kvclear
kvclear() {
    rm -rf "${KV_USER_DIR:-$default_kv_user_dir}"
}

# src/lib/tomb.sh

get_tomb_mapper()
{
	ls -1 /dev/mapper/tomb.* &> /dev/null
	if [[ $? -eq 0 ]]; then
		ls -1 /dev/mapper/tomb.* | grep ${1}
	else
		echo "none"
	fi
}

# open_tomb requires a cleartext resource name that the function will encrypt to resolve the correct tomb file.
# The name is both used as a mount directory, as well as to determine when some special tombs need to be mounted
# on non-standard mount points, like gpg/ssh.
# $1 - Name of the tomb
# $2 - Identity
# $3 - Passphrase
open_tomb()
{
	local RESOURCE="${1}"
    local IDENTITY="${2}"
    local passphrase=${3}

    # Filenames
    local TOMBID="${IDENTITY}-${RESOURCE}"
    local TOMB_FILE_ENC=$(_encrypt_filename "${IDENTITY}" "${TOMBID}.tomb" ${passphrase})
    local TOMB_FILE="${GRAVEYARD}/${TOMB_FILE_ENC}"
    local TOMB_KEY_FILE_ENC=$(_encrypt_filename "${IDENTITY}" "${TOMBID}.key" ${passphrase})
    local TOMB_KEY_FILE="${HUSH_DIR}/${TOMB_KEY_FILE_ENC}"

	local mapper=$(get_tomb_mapper ${TOMBID})

    # Some funtions will call this function while not wanting output
    # if the tomb is already open. Any non-nil value means true.
    local SILENT_IF_OPEN=$3

	case ${RESOURCE} in
		gpg)
			local mount_dir="${HOME}/.gnupg"
		;;
		pass)
			local mount_dir="${HOME}/.password-store"
		;;
		ssh)
			local mount_dir="${HOME}/.ssh"
		;;
		mgmt)
			local mount_dir="${HOME}/.tomb/mgmt"
		;;
		*)
			local mount_dir="${HOME}/.tomb/${RESOURCE}"
		;;
	esac

	if [[ "${mapper}" != "none" ]]; then
		if is_luks_mounted "/dev/mapper/tomb.${TOMBID}" ; then
            if [[ -z ${SILENT_IF_OPEN} ]]; then
			    echo "Tomb ${TOMBID} is already open and mounted"
            fi
			return 0
		fi
	fi

	if [[ ! -f "${TOMB_FILE}" ]]; then
		echo "No tomb file ${TOMB_FILE} found"
		return 2
	fi

    if [[ ! -f "${TOMB_KEY_FILE}" ]]; then
        echo "No key file ${TOMB_KEY_FILE} found"
		return 2
	fi

	# checks if the gpg coffin is mounted
    local COFFIN_NAME=$(_encrypt_filename "${IDENTITY}" "coffin-${IDENTITY}-gpg" "$passphrase")
	if ! is_luks_mounted "/dev/mapper/${COFFIN_NAME}" ; then
		open_coffin ${IDENTITY} ${passphrase}

	fi

	if [[ ! -d ${mount_dir} ]]; then
		mkdir -p ${mount_dir}
	fi

	tomb open -g -k "${TOMB_KEY_FILE}" "${TOMB_FILE}" "${mount_dir}"

    # Either add the only SSH key, or all of them if we have a script
	if [[ "${RESOURCE}" == "ssh" ]]; then
                local ssh_add_script="${HOME}/.ssh/ssh-add"
                if [[ -e ${ssh_add_script} ]]; then
                        ${ssh_add_script}
                else
		        ssh-add
                fi
	fi
}

close_tomb()
{
	local RESOURCE="${1}"
    local IDENTITY="$(_identity_active_or_specified ${2})"

    local FULL_LABEL="${IDENTITY}-${RESOURCE}"

	if ! get_tomb_mapper ${IDENTITY}-${RESOURCE} &> /dev/null ; then
		_message "Tomb ${IDENTITY}-${RESOURCE} is already closed"
		return 0
	fi

        # If the concatenated string is too long, cut it to 16 chars
        if [[ ${#FULL_LABEL} -ge 16 ]]; then
                FULL_LABEL=${FULL_LABEL:0:16}
        fi

        # Then close it
	tomb close ${FULL_LABEL}

	if [[ "${RESOURCE}" == "ssh" ]]; then
		ssh-add -D
	fi

}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Plays sounds
# Package `sox` provides the "play" program: sudo apt-get install sox
play_sound()
{
	if [ ${SDCARD_QUIET} -gt 0 ] || [ ! -x "$(command -v play)" ]; then
		return 1
	fi

	case $1 in

		plugged)
			if [ -f /usr/share/sounds/freedesktop/stereo/device-added.oga ]; then
				play -V0 /usr/share/sounds/freedesktop/stereo/device-added.oga &> /dev/null
			fi
		;;

		unplugged)

			if [ -f /usr/share/sounds/freedesktop/stereo/device-removed.oga ]; then
				play -V0 /usr/share/sounds/freedesktop/stereo/device-removed.oga &> /dev/null
			fi
		;;

		*)
			return 1
		;;
	esac
}

# :command.command_functions

# :command.function
risks_hush_mount_command() {
  # src/hush_mount_command.sh
  echo "# this file is located in 'src/hush_mount_command.sh'"
  echo "# code for 'risks hush mount' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_hush_rw_command() {
  # src/hush_rw_command.sh
  echo "# this file is located in 'src/hush_rw_command.sh'"
  echo "# code for 'risks hush rw' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_hush_ro_command() {
  # src/hush_ro_command.sh
  echo "# this file is located in 'src/hush_ro_command.sh'"
  echo "# code for 'risks hush ro' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_hush_umount_command() {
  # src/hush_umount_command.sh
  echo "# this file is located in 'src/hush_umount_command.sh'"
  echo "# code for 'risks hush umount' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_format_sdcard_command() {
  # src/format_sdcard_command.sh
  echo "# this file is located in 'src/format_sdcard_command.sh'"
  echo "# code for 'risks format sdcard' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_format_backup_command() {
  # src/format_backup_command.sh
  echo "# this file is located in 'src/format_backup_command.sh'"
  echo "# code for 'risks format backup' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_new_identity_command() {
  # src/new_identity_command.sh
  echo "# this file is located in 'src/new_identity_command.sh'"
  echo "# code for 'risks new identity' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_new_tomb_command() {
  # src/new_tomb_command.sh
  echo "# this file is located in 'src/new_tomb_command.sh'"
  echo "# code for 'risks new tomb' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_new_backup_command() {
  # src/new_backup_command.sh
  echo "# this file is located in 'src/new_backup_command.sh'"
  echo "# code for 'risks new backup' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_open_command() {
  # src/open_command.sh
  echo "# this file is located in 'src/open_command.sh'"
  echo "# code for 'risks open' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_close_command() {
  # src/close_command.sh
  echo "# this file is located in 'src/close_command.sh'"
  echo "# code for 'risks close' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_list_command() {
  # src/list_command.sh
  echo "# this file is located in 'src/list_command.sh'"
  echo "# code for 'risks list' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_slam_command() {
  # src/slam_command.sh
  echo "# this file is located in 'src/slam_command.sh'"
  echo "# code for 'risks slam' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_gpgpass_command() {
  # src/gpgpass_command.sh
  echo "# this file is located in 'src/gpgpass_command.sh'"
  echo "# code for 'risks gpgpass' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_kv_set_command() {
  # src/kv_set_command.sh
  echo "# this file is located in 'src/kv_set_command.sh'"
  echo "# code for 'risks kv set' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_kv_get_command() {
  # src/kv_get_command.sh
  echo "# this file is located in 'src/kv_get_command.sh'"
  echo "# code for 'risks kv get' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_kv_unset_command() {
  # src/kv_unset_command.sh
  echo "# this file is located in 'src/kv_unset_command.sh'"
  echo "# code for 'risks kv unset' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_kv_list_command() {
  # src/kv_list_command.sh
  echo "# this file is located in 'src/kv_list_command.sh'"
  echo "# code for 'risks kv list' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_kv_clean_command() {
  # src/kv_clean_command.sh
  echo "# this file is located in 'src/kv_clean_command.sh'"
  echo "# code for 'risks kv clean' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_load_command() {
  # src/load_command.sh
  echo "# this file is located in 'src/load_command.sh'"
  echo "# code for 'risks load' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risks_save_command() {
  # src/save_command.sh
  echo "# this file is located in 'src/save_command.sh'"
  echo "# code for 'risks save' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    risks_usage
    exit
    ;;

  esac

  # :command.environment_variables_filter
  export SDCARD_ENC_PART="${SDCARD_ENC_PART:-/dev/hush}"
  export SDCARD_ENC_PART_MAPPER="${SDCARD_ENC_PART_MAPPER:-hush}"
  export SDCARD_QUIET="${SDCARD_QUIET:-0}"
  export HUSHDIR="${HUSHDIR:-~/.hush}"
  export GRAVEYARD="${GRAVEYARD:-~/.graveyard}"

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  hush )
    action="hush"
    shift
    risks_hush_parse_requirements "$@"
    shift $#
    ;;

  format )
    action="format"
    shift
    risks_format_parse_requirements "$@"
    shift $#
    ;;

  new )
    action="new"
    shift
    risks_new_parse_requirements "$@"
    shift $#
    ;;

  open )
    action="open"
    shift
    risks_open_parse_requirements "$@"
    shift $#
    ;;

  close )
    action="close"
    shift
    risks_close_parse_requirements "$@"
    shift $#
    ;;

  list )
    action="list"
    shift
    risks_list_parse_requirements "$@"
    shift $#
    ;;

  slam )
    action="slam"
    shift
    risks_slam_parse_requirements "$@"
    shift $#
    ;;

  gpgpass )
    action="gpgpass"
    shift
    risks_gpgpass_parse_requirements "$@"
    shift $#
    ;;

  kv )
    action="kv"
    shift
    risks_kv_parse_requirements "$@"
    shift $#
    ;;

  load )
    action="load"
    shift
    risks_load_parse_requirements "$@"
    shift $#
    ;;

  save )
    action="save"
    shift
    risks_save_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risks_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_hush_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  mount )
    action="mount"
    shift
    risks_hush_mount_parse_requirements "$@"
    shift $#
    ;;

  rw )
    action="rw"
    shift
    risks_hush_rw_parse_requirements "$@"
    shift $#
    ;;

  ro )
    action="ro"
    shift
    risks_hush_ro_parse_requirements "$@"
    shift $#
    ;;

  umount )
    action="umount"
    shift
    risks_hush_umount_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risks_hush_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_mount_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_hush_mount_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush mount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_rw_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_hush_rw_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush rw"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_ro_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_hush_ro_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush ro"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_umount_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_hush_umount_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush umount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_format_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_format_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  sdcard )
    action="sdcard"
    shift
    risks_format_sdcard_parse_requirements "$@"
    shift $#
    ;;

  backup )
    action="backup"
    shift
    risks_format_backup_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risks_format_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_format_sdcard_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_format_sdcard_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="format sdcard"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[device]+x} ]]; then

        args[device]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[device]+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks format sdcard DEVICE [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_format_backup_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_format_backup_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="format backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[device]+x} ]]; then

        args[device]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[device]+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks format backup DEVICE [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_new_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_new_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  identity )
    action="identity"
    shift
    risks_new_identity_parse_requirements "$@"
    shift $#
    ;;

  tomb )
    action="tomb"
    shift
    risks_new_tomb_parse_requirements "$@"
    shift $#
    ;;

  backup )
    action="backup"
    shift
    risks_new_backup_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risks_new_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_new_identity_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_new_identity_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="new identity"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --log | -l )

      # :flag.case_no_arg
      args[--log]=1
      shift
      ;;

    # :flag.case
    --log-file | -f )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--log-file]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[name]+x} ]]; then

        args[name]=$1
        shift
      elif [[ -z ${args[email]+x} ]]; then

        args[email]=$1
        shift
      elif [[ -z ${args[expiry_date]+x} ]]; then

        args[expiry_date]=$1
        shift
      elif [[ -z ${args[backup_device]+x} ]]; then

        args[backup_device]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[name]+x} ]]; then
    printf "missing required argument: NAME\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
    exit 1
  fi
  if [[ -z ${args[email]+x} ]]; then
    printf "missing required argument: EMAIL\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
    exit 1
  fi
  if [[ -z ${args[expiry_date]+x} ]]; then
    printf "missing required argument: EXPIRY_DATE\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
    exit 1
  fi
  if [[ -z ${args[backup_device]+x} ]]; then
    printf "missing required argument: BACKUP_DEVICE\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--log-file]:-} ]] || args[--log-file]="default"

}

# :command.parse_requirements
risks_new_tomb_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_new_tomb_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="new tomb"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --log | -l )

      # :flag.case_no_arg
      args[--log]=1
      shift
      ;;

    # :flag.case
    --log-file | -f )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--log-file]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[tomb_name]+x} ]]; then

        args[tomb_name]=$1
        shift
      elif [[ -z ${args[size]+x} ]]; then

        args[size]=$1
        shift
      elif [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[tomb_name]+x} ]]; then
    printf "missing required argument: TOMB_NAME\nusage: risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
    exit 1
  fi
  if [[ -z ${args[size]+x} ]]; then
    printf "missing required argument: SIZE\nusage: risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--log-file]:-} ]] || args[--log-file]="default"

}

# :command.parse_requirements
risks_new_backup_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_new_backup_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="new backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[device]+x} ]]; then

        args[device]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[device]+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks new backup DEVICE [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_open_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_open_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --log | -l )

      # :flag.case_no_arg
      args[--log]=1
      shift
      ;;

    # :flag.case
    --log-file | -f )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--log-file]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[store]+x} ]]; then

        args[store]=$1
        shift
      elif [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[store]+x} ]]; then
    printf "missing required argument: STORE\nusage: risks open STORE [IDENTITY] [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--log-file]:-} ]] || args[--log-file]="default"

}

# :command.parse_requirements
risks_close_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_close_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --log | -l )

      # :flag.case_no_arg
      args[--log]=1
      shift
      ;;

    # :flag.case
    --log-file | -f )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--log-file]="$2"
        shift
        shift
      else
        printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[store]+x} ]]; then

        args[store]=$1
        shift
      elif [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[store]+x} ]]; then
    printf "missing required argument: STORE\nusage: risks close STORE [IDENTITY] [options]\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--log-file]:-} ]] || args[--log-file]="default"

}

# :command.parse_requirements
risks_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_list_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[store]+x} ]]; then

        args[store]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[store]+x} ]]; then
    printf "missing required argument: STORE\nusage: risks list STORE\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_slam_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_slam_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="slam"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_gpgpass_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_gpgpass_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="gpgpass"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  set )
    action="set"
    shift
    risks_kv_set_parse_requirements "$@"
    shift $#
    ;;

  get )
    action="get"
    shift
    risks_kv_get_parse_requirements "$@"
    shift $#
    ;;

  unset )
    action="unset"
    shift
    risks_kv_unset_parse_requirements "$@"
    shift $#
    ;;

  list )
    action="list"
    shift
    risks_kv_list_parse_requirements "$@"
    shift $#
    ;;

  clean )
    action="clean"
    shift
    risks_kv_clean_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risks_kv_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_set_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_set_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="kv set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      elif [[ -z ${args[value]+x} ]]; then

        args[value]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv set KEY VALUE\n"
    exit 1
  fi
  if [[ -z ${args[value]+x} ]]; then
    printf "missing required argument: VALUE\nusage: risks kv set KEY VALUE\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_get_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_get_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="kv get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv get KEY\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_unset_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_unset_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="kv unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv unset KEY\n"
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_list_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="kv list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_clean_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_kv_clean_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="kv clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_load_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_load_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="load"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risks_save_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risks_save_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="save"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "hush" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_hush_usage
    else
      risks_hush_command
    fi

  elif [[ $action == "hush mount" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_hush_mount_usage
    else
      risks_hush_mount_command
    fi

  elif [[ $action == "hush rw" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_hush_rw_usage
    else
      risks_hush_rw_command
    fi

  elif [[ $action == "hush ro" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_hush_ro_usage
    else
      risks_hush_ro_command
    fi

  elif [[ $action == "hush umount" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_hush_umount_usage
    else
      risks_hush_umount_command
    fi

  elif [[ $action == "format" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_format_usage
    else
      risks_format_command
    fi

  elif [[ $action == "format sdcard" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_format_sdcard_usage
    else
      risks_format_sdcard_command
    fi

  elif [[ $action == "format backup" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_format_backup_usage
    else
      risks_format_backup_command
    fi

  elif [[ $action == "new" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_new_usage
    else
      risks_new_command
    fi

  elif [[ $action == "new identity" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_new_identity_usage
    else
      risks_new_identity_command
    fi

  elif [[ $action == "new tomb" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_new_tomb_usage
    else
      risks_new_tomb_command
    fi

  elif [[ $action == "new backup" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_new_backup_usage
    else
      risks_new_backup_command
    fi

  elif [[ $action == "open" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_open_usage
    else
      risks_open_command
    fi

  elif [[ $action == "close" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_close_usage
    else
      risks_close_command
    fi

  elif [[ $action == "list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_list_usage
    else
      risks_list_command
    fi

  elif [[ $action == "slam" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_slam_usage
    else
      risks_slam_command
    fi

  elif [[ $action == "gpgpass" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_gpgpass_usage
    else
      risks_gpgpass_command
    fi

  elif [[ $action == "kv" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_usage
    else
      risks_kv_command
    fi

  elif [[ $action == "kv set" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_set_usage
    else
      risks_kv_set_command
    fi

  elif [[ $action == "kv get" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_get_usage
    else
      risks_kv_get_command
    fi

  elif [[ $action == "kv unset" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_unset_usage
    else
      risks_kv_unset_command
    fi

  elif [[ $action == "kv list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_list_usage
    else
      risks_kv_list_command
    fi

  elif [[ $action == "kv clean" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_kv_clean_usage
    else
      risks_kv_clean_command
    fi

  elif [[ $action == "load" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_load_usage
    else
      risks_load_command
    fi

  elif [[ $action == "save" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risks_save_usage
    else
      risks_save_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
