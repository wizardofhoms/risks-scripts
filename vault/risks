#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
risks_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks - Identity creation and management tool\n"
		echo

	else
		printf "risks - Identity creation and management tool\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks [command]\n"
	printf "  risks [command] --help | -h\n"
	printf "  risks --version | -v\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  hush      Manage the hush partition mount points and read/write permissions"
	echo "  backup    Manage, mount, restore or use backup devices and partitions"
	echo "  new       Create new identities, data stores or backups"
	echo "  open      Open an identity or some of its associated data stores"
	echo "  close     Close an identity or some of its associated data stores"
	echo "  list      Show currently open data stores"
	echo "  slam      Close all active identities and unmount hush partition"
	echo "  gpgpass   Copy the identity GPG passphrase to the clipboard"
	echo "  load      Copy some resource to a VM where to use it (completed)"
	echo "  save      Move some data coming from another VM to a (tomb) directory"
	echo "  kv        Manage the small key=value store used by other commands/functions"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo
		echo "  --version, -v"
		printf "    Show version number\n"
		echo

		# :command.usage_environment_variables
		printf "Environment Variables:\n"

		# :environment_variable.usage
		echo "  SDCARD_ENC_PART"
		printf "    Device file path to the hush partition\n"
		printf "    Default: /dev/hush\n"
		echo

		# :environment_variable.usage
		echo "  SDCARD_ENC_PART_MAPPER"
		printf "    Name of LUKS mapper to hush partition\n"
		printf "    Default: hush\n"
		echo

		# :environment_variable.usage
		echo "  SDCARD_QUIET"
		printf "    Enable sound when hush device is mounted (0: enabled, 1: disabled)\n"
		printf "    Default: 0\n"
		echo

		# :environment_variable.usage
		echo "  HUSH_DIR"
		printf "    Directory mount point for the hush device\n"
		printf "    Default: /home/user/.hush\n"
		echo

		# :environment_variable.usage
		echo "  GRAVEYARD"
		printf "    Directory where to store tomb files\n"
		printf "    Default: /home/user/.graveyard\n"
		echo

		# :environment_variable.usage
		echo "  BACKUP_MAPPER"
		printf "    Name of LUKS mapper to backup partition\n"
		printf "    Default: pendev\n"
		echo

	fi
}

# :command.usage
risks_hush_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush - Manage the hush partition mount points and read/write permissions\n"
		echo

	else
		printf "risks hush - Manage the hush partition mount points and read/write permissions\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush [command]\n"
	printf "  risks hush [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  mount    Mount the hush drive"
	echo "  rw       Set read-write permissions on the hush partition"
	echo "  ro       Set read-only permissions on the hush partition"
	echo "  umount   Unmount the hush drive"
	echo "  format   Format a drive for storing identity secrets (GPG/coffin/age keys)"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_hush_mount_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush mount - Mount the hush drive\n"
		echo

	else
		printf "risks hush mount - Mount the hush drive\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush mount\n"
	printf "  risks hush mount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_hush_rw_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush rw - Set read-write permissions on the hush partition\n"
		echo

	else
		printf "risks hush rw - Set read-write permissions on the hush partition\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush rw\n"
	printf "  risks hush rw --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_hush_ro_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush ro - Set read-only permissions on the hush partition\n"
		echo

	else
		printf "risks hush ro - Set read-only permissions on the hush partition\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush ro\n"
	printf "  risks hush ro --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_hush_umount_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush umount - Unmount the hush drive\n"
		echo

	else
		printf "risks hush umount - Unmount the hush drive\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush umount\n"
	printf "  risks hush umount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_hush_format_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks hush format - Format a drive for storing identity secrets (GPG/coffin/age keys)\n"
		echo

	else
		printf "risks hush format - Format a drive for storing identity secrets (GPG/coffin/age keys)\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks hush format DEVICE [options]\n"
	printf "  risks hush format --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --size-percent, -P PERCENT"
		printf "    Size of encrypted partition, as a percentage of the entire drive\n"
		printf "    Default: 90\n"
		echo

		# :flag.usage
		echo "  --size-absolute, -A SIZE"
		printf "    Size of encrypted partition, in absolute terms, WITH unit (eg. 100G, 20M,\n    etc)\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  DEVICE"
		printf "    Device file of the sdcard drive (must be a whole drive without a partition\n    number, eg. /dev/sda)\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  hush format --size-absolute 200M /dev/xvdi   # The encrypted part will be 200M\n  in size\n"
		printf "  hush format --size-percent 70 /dev/xvdi      # The encrypted part takes 70% of\n  the drive\n"
		echo

	fi
}

# :command.usage
risks_backup_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup - Manage, mount, restore or use backup devices and partitions\n"
		echo

	else
		printf "risks backup - Manage, mount, restore or use backup devices and partitions\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup [command]\n"
	printf "  risks backup [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  mount      Mount the backup partition/device"
	echo "  umount     Unmount the current backup drive"
	echo "  format     Format and setup a drive for as a risks backup medium"
	echo "  identity   Backup the graveyard and the GPG coffin file for the current identity, active or specified."
	echo "  hush       Backup only the raw hush device image"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_backup_mount_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup mount - Mount the backup partition/device\n"
		echo

	else
		printf "risks backup mount - Mount the backup partition/device\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup mount BACKUP_DEVICE\n"
	printf "  risks backup mount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  BACKUP_DEVICE"
		printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
		echo

	fi
}

# :command.usage
risks_backup_umount_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup umount - Unmount the current backup drive\n"
		echo

	else
		printf "risks backup umount - Unmount the current backup drive\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup umount\n"
	printf "  risks backup umount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_backup_format_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup format - Format and setup a drive for as a risks backup medium\n"
		echo

	else
		printf "risks backup format - Format and setup a drive for as a risks backup medium\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup format DEVICE [options]\n"
	printf "  risks backup format --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  DEVICE"
		printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  backup format /dev/xvdi\n"
		echo

	fi
}

# :command.usage
risks_backup_identity_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup identity - Backup the graveyard and the GPG coffin file for the current identity, active or specified.\n"
		echo

	else
		printf "risks backup identity - Backup the graveyard and the GPG coffin file for the current identity, active or specified.\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup identity [IDENTITY] [options]\n"
	printf "  risks backup identity --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --log-file, -f LOGFILE"
		printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Name of identity to backup. (Current identity if not specified)\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  backup identity john_doe\n"
		printf "  backup identity\n"
		echo

	fi
}

# :command.usage
risks_backup_hush_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks backup hush - Backup only the raw hush device image\n"
		echo

	else
		printf "risks backup hush - Backup only the raw hush device image\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks backup hush\n"
	printf "  risks backup hush --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_new_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks new - Create new identities, data stores or backups\n"
		echo

	else
		printf "risks new - Create new identities, data stores or backups\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks new [command]\n"
	printf "  risks new [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  identity   Create a new GPG identity, with SSH/password-store/Signal and associated tombs"
	echo "  tomb       Create a new tomb"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_new_identity_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks new identity - Create a new GPG identity, with SSH/password-store/Signal and associated tombs\n"
		echo

	else
		printf "risks new identity - Create a new GPG identity, with SSH/password-store/Signal and associated tombs\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
	printf "  risks new identity --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --log, -l"
		printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
		echo

		# :flag.usage
		echo "  --log-file, -f LOGFILE"
		printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  NAME"
		printf "    Alias/nym/name to use for the identity (can include spaces if full name, but\n    use quotes accordingly)\n"
		echo

		# :argument.usage
		echo "  EMAIL"
		printf "    Email address to use for the GPG identity\n"
		echo

		# :argument.usage
		echo "  EXPIRY_DATE"
		printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
		echo

		# :argument.usage
		echo "  BACKUP_DEVICE"
		printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  new identity 'John Doe' john.doe@mail.com '1 year' /dev/xvdj\n"
		echo

	fi
}

# :command.usage
risks_new_tomb_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks new tomb - Create a new tomb\n"
		echo

	else
		printf "risks new tomb - Create a new tomb\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
	printf "  risks new tomb --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --log, -l"
		printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
		echo

		# :flag.usage
		echo "  --log-file, -f LOGFILE"
		printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  TOMB_NAME"
		printf "    Name/label to use for the tomb\n"
		echo

		# :argument.usage
		echo "  SIZE"
		printf "    Size (in MB) of the tomb\n"
		echo

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity for which to create the tomb. Optional: the active identity is used\n    if no identity is specified\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  new tomb Data 100 john_doe\n"
		echo

	fi
}

# :command.usage
risks_open_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks open - Open an identity or some of its associated data stores\n"
		echo

	else
		printf "risks open - Open an identity or some of its associated data stores\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks open RESOURCE [IDENTITY] [options]\n"
	printf "  risks open --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --log, -l"
		printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
		echo

		# :flag.usage
		echo "  --log-file, -f LOGFILE"
		printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  RESOURCE"
		printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to open\n"
		echo

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity owning the store. Optional only if a the store to open is a tomb\n    and an identity is active.\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  open identity john_doe       # Opens gpg coffin and mgmt/pass/ssh/signal tombs\n"
		printf "  open gpg john_doe            # Opens the GPG keyring for identity 'john_doe'\n"
		printf "  open ssh                     # Opens the ssh tomb for the active identity\n"
		printf "  open pass [identity]         # Opens the password-store for active identity\n"
		echo

	fi
}

# :command.usage
risks_close_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks close - Close an identity or some of its associated data stores\n"
		echo

	else
		printf "risks close - Close an identity or some of its associated data stores\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks close RESOURCE [IDENTITY] [options]\n"
	printf "  risks close --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --log, -l"
		printf "    Log the command's output to the identity log file, or the file path given\n    with -f/--log-file\n"
		echo

		# :flag.usage
		echo "  --log-file, -f LOGFILE"
		printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  RESOURCE"
		printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to close\n"
		echo

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity owning the store. Optional only if a the store to close is a tomb\n    and an identity is active.\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  close identity john_doe      # Closes gpg coffin/all tombs for 'john_doe'\n"
		printf "  close identity               # Closes gpg coffin/all tombs for active identity\n"
		printf "  close pass                   # Closes password-store tomb for active identity\n"
		echo

	fi
}

# :command.usage
risks_list_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks list - Show currently open data stores\n"
		echo

	else
		printf "risks list - Show currently open data stores\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks list [RESOURCE]\n"
	printf "  risks list --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  RESOURCE"
		printf "    Datastore types to list (all if not provided)\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  list coffins         # Lists open GPG coffins\n"
		printf "  list tombs           # Lists open tombs\n"
		echo

	fi
}

# :command.usage
risks_slam_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks slam - Close all active identities and unmount hush partition\n"
		echo

	else
		printf "risks slam - Close all active identities and unmount hush partition\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks slam [options]\n"
	printf "  risks slam --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

	fi
}

# :command.usage
risks_gpgpass_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks gpgpass - Copy the identity GPG passphrase to the clipboard\n"
		echo

	else
		printf "risks gpgpass - Copy the identity GPG passphrase to the clipboard\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks gpgpass [IDENTITY] [options]\n"
	printf "  risks gpgpass --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --timeout, -t TIMEOUT"
		printf "    Clear the clipboard after this many seconds\n"
		printf "    Default: 45\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity for which to copy the GPG passphrase. Optional if an identity is\n    active.\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  gpgpass john_doe         # Copy john_doe's GPG key passphrase\n"
		printf "  gpgpass                  # Copy the current identity's GPG key passphrase\n"
		echo

	fi
}

# :command.usage
risks_load_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks load - Copy some resource to a VM where to use it (completed)\n"
		echo

	else
		printf "risks load - Copy some resource to a VM where to use it (completed)\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks load RESOURCE SOURCE_VM [IDENTITY] [options]\n"
	printf "  risks load --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --close-tomb, -c"
		printf "    Immediately close the tomb after sending the files\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  RESOURCE"
		printf "    Name of a tomb containing the data to be transfered. The tomb will be opened\n    if needed\n"
		echo

		# :argument.usage
		echo "  SOURCE_VM"
		printf "    Destination VM\n"
		echo

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity owning the tomb (optional if an identity is active)\n"
		echo

	fi
}

# :command.usage
risks_save_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
		echo

	else
		printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks save SOURCE_VM RESOURCE [IDENTITY] [options]\n"
	printf "  risks save --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --close-tomb, -c"
		printf "    Immediately close the tomb after saving the files\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  SOURCE_VM"
		printf "    Source VM, which has an equivalent directory in ~/QubesIncoming/\n"
		echo

		# :argument.usage
		echo "  RESOURCE"
		printf "    Name of a tomb containing the data to be transfered. The tomb will be opened\n    if needed\n"
		echo

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity owning the tomb (optional if an identity is active)\n"
		echo

	fi
}

# :command.usage
risks_kv_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv - Manage the small key=value store used by other commands/functions\n"
		echo

	else
		printf "risks kv - Manage the small key=value store used by other commands/functions\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv [command]\n"
	printf "  risks kv [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  set     Set a variable to a value"
	echo "  get     Get the value of a variable"
	echo "  unset   Unset an existing variable"
	echo "  list    List all key=value pairs in the store"
	echo "  clean   Delete all key=value pairs in the store"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_kv_set_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv set - Set a variable to a value\n"
		echo

	else
		printf "risks kv set - Set a variable to a value\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv set KEY VALUE\n"
	printf "  risks kv set --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  KEY"
		printf "    Name of of key to set\n"
		echo

		# :argument.usage
		echo "  VALUE"
		printf "    Value to assign to the key\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  set signalVM MySignalVM      # Sets the key 'signalVM' to 'mySignalVM' in the\n  store\n"
		echo

	fi
}

# :command.usage
risks_kv_get_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv get - Get the value of a variable\n"
		echo

	else
		printf "risks kv get - Get the value of a variable\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv get KEY\n"
	printf "  risks kv get --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  KEY"
		printf "    Name of of key to show\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  get signalVM              # Prints the value of the key 'signalVM'\n"
		echo

	fi
}

# :command.usage
risks_kv_unset_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv unset - Unset an existing variable\n"
		echo

	else
		printf "risks kv unset - Unset an existing variable\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv unset KEY\n"
	printf "  risks kv unset --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  KEY"
		printf "    Name of of key to delete/unset\n"
		echo

		# :command.usage_examples
		printf "Examples:\n"
		printf "  unset signalVM            # Deletes the key 'signalVM' in the key-value store\n"
		echo

	fi
}

# :command.usage
risks_kv_list_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv list - List all key=value pairs in the store\n"
		echo

	else
		printf "risks kv list - List all key=value pairs in the store\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv list\n"
	printf "  risks kv list --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risks_kv_clean_usage() {
	if [[ -n $long_usage ]]; then
		printf "risks kv clean - Delete all key=value pairs in the store\n"
		echo

	else
		printf "risks kv clean - Delete all key=value pairs in the store\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risks kv clean\n"
	printf "  risks kv clean --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
normalize_input() {
	local arg flags

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for (( i=0 ; i < ${#flags} ; i++ )); do
				input+=("-${flags:i:1}")
			done
		else
			input+=("$arg")
		fi

		shift
	done
}
# :command.inspect_args
inspect_args() {
	readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
	if (( ${#args[@]} )); then
		echo args:
		for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
	else
		echo args: none
	fi

	if (( ${#other_args[@]} )); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi
}

# :command.user_lib
# src/lib/backup.sh

# The identity needs its own backup directory.
setup_identity_backup ()

{
		local BACKUP_GRAVEYARD_ROOT="${BACKUP_MOUNT_DIR}/graveyard"

		local GRAVEYARD_DIRECTORY_ENC IDENTITY_GRAVEYARD_PATH

		_verbose "Creating identity graveyard directory on backup"

		# The directory name in cleartext is simply the identity name
		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
		IDENTITY_BACKUP_GRAVEYARD_PATH="${BACKUP_GRAVEYARD_ROOT}/${GRAVEYARD_DIRECTORY_ENC}"

		_verbose "Creating directory $IDENTITY_GRAVEYARD_PATH"
		mkdir -p "$IDENTITY_BACKUP_GRAVEYARD_PATH"

		# And setup fscrypt protectors on it.
		_verbose "Setting up fscrypt protectors on directory"
		echo "$FILE_ENCRYPTION_KEY" | sudo fscrypt encrypt "$IDENTITY_BACKUP_GRAVEYARD_PATH" \
			 --quiet --source=custom_passphrase --name="$GRAVEYARD_DIRECTORY_ENC"
		_catch "Failed to encrypt identity graveyard in backup"
}

# backup_identity_gpg simply copies the raw coffin file in the graveyard backup directory root,
# since like on the OS graveyard, one must access it without having access to the graveyard in
# the first place.
backup_identity_gpg ()

{
		local BACKUP_GRAVEYARD_ROOT="${BACKUP_MOUNT_DIR}/graveyard"

		local GRAVEYARD_COFFIN_FILE IDENTITY_COFFIN_PATH COFFIN_BACKUP_PATH

		# The directory name in cleartext is simply the identity name
		GRAVEYARD_COFFIN_FILE=$(_encrypt_filename "coffin-$IDENTITY-gpg")
		IDENTITY_COFFIN_PATH="${GRAVEYARD}/${GRAVEYARD_COFFIN_FILE}"

		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
		COFFIN_BACKUP_PATH="${BACKUP_GRAVEYARD_ROOT}/${GRAVEYARD_DIRECTORY_ENC}/${GRAVEYARD_COFFIN_FILE}"

		if [[ -e ${IDENTITY_COFFIN_PATH} ]]; then
				sudo chattr -i "${IDENTITY_COFFIN_PATH}"

		fi

		cp -r "$IDENTITY_COFFIN_PATH" "$COFFIN_BACKUP_PATH"
		sudo chattr +i "${IDENTITY_COFFIN_PATH}"

}

# src/lib/cleanup.sh

# This file contains:
# - Functions needed to register variables to be cleaned.

# - Code to be triggered on exit/returns to perform security cleanup
# - Any variable in which code will store some stuff to be treated.

declare -a CLEANUP_VARS

# _defer_cleanup takes an arbitrary amount of variables

# that will be cleaned up further down the workflow
_defer_cleanup ()
{
		_verbose "Variables registered for cleanup: ( ${*} )"
		CLEANUP_VARS+=("$@")
}

# Cleanup anything sensitive before exiting.
# Originally copied from tomb code.
_endgame() {

	# option_value_contains -o ro || {
	# 	# Restore access time of sensitive files
	# 	[[ -z $TOMBFILESSTAT ]] || _restore_stat
	# }

	# Prepare some random material to overwrite vars
	local rr="$RANDOM"
	while [[ ${#rr} -lt 500 ]]; do
		rr+="$RANDOM"
	done

	# Ensure no information is left in unallocated memory
	IDENTITY="$rr";		        unset IDENTITY

	FILE_ENCRYPTION_KEY="$rr";  unset FILE_ENCRYPTION_KEY

	GPG_PASS="$rr";		        unset GPG_PASS

}

# Trap functions for the _endgame event
TRAPINT()  { _endgame INT;	}
TRAPEXIT() { _endgame EXIT;	}
TRAPHUP()  { _endgame HUP;	}
TRAPQUIT() { _endgame QUIT;	}
TRAPABRT() { _endgame ABORT; }
TRAPKILL() { _endgame KILL;	}
TRAPPIPE() { _endgame PIPE;	}
TRAPTERM() { _endgame TERM;	}
TRAPSTOP() { _endgame STOP;	}

# src/lib/coffin.sh

# Generates, setup and formats a LUKS partition to be used as a coffin identity files
gen_coffin()

{
		local key_filename key_file coffin_filename coffin_file coffin_name identity_fs

		# Filenames
		key_filename=$(_encrypt_filename "${IDENTITY}-gpg.key")
		key_file="${HUSH_DIR}/${key_filename}"
		coffin_filename=$(_encrypt_filename "${IDENTITY}-gpg.coffin")
		coffin_file="${GRAVEYARD}/${coffin_filename}"
		coffin_name=$(_encrypt_filename "coffin-${IDENTITY}-gpg")
		identity_fs=$(_encrypt_filename "${IDENTITY}-gpg")

		_verbose "Generating coffin key (compatible with QRCode printing)"
		head --bytes=64 /dev/urandom > "$key_file"
		_verbose "Protecting against deletions"
		sudo chattr +i "$key_file"
		_verbose "Testing immutability of key file"
		_verbose "Output of lsattr:"
		_run lsattr "${HUSH_DIR}"
		_verbose "Output should look like (filename is encrypted):"
		_verbose "—-i———e—- /home/user/.hush/JRklfdjklb334blkfd"

		_verbose "Creating the coffin container (50MB)"
		_run dd if=/dev/urandom of="$coffin_file" bs=1M count=50

		# Encryption
		_verbose "Laying the coffin LUKS inside the container"
		_run sudo cryptsetup -v -q --cipher aes-xts-plain64 --master-key-file "$key_file" \
						--key-size 512 --hash sha512 --iter-time 5000 --use-random \
						luksFormat "${coffin_file}" "$key_file"
		_catch "Failed to lay setup and format the coffin LUKS filesystem"
		_verbose "Testing coffin detailed output (luksDump)"
		_run sudo cryptsetup luksDump "$coffin_file"

		_catch "Failed to dump coffin LUKS filesystem"
		_verbose "Normally, we should see the UUID of the coffin, and only one key configured for it"


		_verbose "Opening the coffin for setup"
		_run sudo cryptsetup open --type luks "$coffin_file" "$coffin_name" --key-file "$key_file"
		_catch "Failed to open the coffin LUKS filesystem"

		_verbose "Testing coffin status"
		_run sudo cryptsetup status "$coffin_name"

		_catch "Failed to get status of coffin LUKS filesystem"

		_verbose "Formatting the coffin filesystem (ext4)"
		_run sudo mkfs.ext4 -m 0 -L "$identity_fs" "/dev/mapper/${coffin_name}"
		_catch "Failed to make ext4 filesystem on coffin partition"
}

# open_coffin requires both an identity name and its corresponding passphrase
open_coffin()
{
		local key_filename key_file coffin_filename coffin_file mapper mount_dir

		key_filename=$(_encrypt_filename "${IDENTITY}-gpg.key")
		key_file="${HUSH_DIR}/${key_filename}"
		coffin_filename=$(_encrypt_filename "${IDENTITY}-gpg.coffin")
		coffin_file="${GRAVEYARD}/${coffin_filename}"
		mapper=$(_encrypt_filename "coffin-${IDENTITY}-gpg")

	mount_dir="${HOME}/.gnupg"

	if [[ ! -f "${coffin_file}" ]]; then
		_failure "I'm looking for $coffin_file but no coffin file found in $GRAVEYARD"
	fi

	if is_luks_mounted "/dev/mapper/${mapper}" ; then
		_verbose "Coffin file $coffin_file is already open and mounted"
		return 0
	fi

		if ! is_luks_open "${mapper}"; then
				if ! _run sudo cryptsetup open --type luks "$coffin_file" "$mapper" --key-file "$key_file" ; then
			_failure "I can not open the coffin file $coffin_file"
		fi
	fi

		mkdir -p "${mount_dir}" &> /dev/null

		if ! _run sudo mount -o rw,user /dev/mapper/"${mapper}" "$mount_dir" ; then
		_failure "Coffin file $coffin_file can not be mounted on $mount_dir"
	fi

	_verbose "Coffin $coffin_file has been opened in $mount_dir"

		sudo chown "${USER}" "$mount_dir"
		sudo chmod 0700 "$mount_dir"

		# Set the identity as active, and unlock access to its GRAVEYARD directory
		_set_active_identity "$IDENTITY"

		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
		IDENTITY_GRAVEYARD_PATH="${GRAVEYARD}/$GRAVEYARD_DIRECTORY_ENC"

		# Ask fscrypt to let us access it. While this will actually decrypt the files'
		# names and content, this does not prevent our own obfuscated names; the end
		# result is that all NAMES are obfuscated twice (once us, once fscrypt) and
		# the contents are encrypted once (fscrypt).
		echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$IDENTITY_GRAVEYARD_PATH" --quiet

		_verbose "Identity directory ($IDENTITY_GRAVEYARD_PATH) is unlocked"
}

close_coffin()
{
		local coffin_filename coffin_file mapper mount_dir

		coffin_filename=$(_encrypt_filename "${IDENTITY}-gpg.coffin")
		coffin_file="${GRAVEYARD}/${coffin_filename}"
		mapper=$(_encrypt_filename "coffin-${IDENTITY}-gpg")

	mount_dir="${HOME}/.gnupg"

		# Gpg-agent is an asshole spawning thousands of processes
		# without anyone to ask for them.... security they said
		gpgconf --kill gpg-agent

	if is_luks_mounted "/dev/mapper/${mapper}" ; then
				if ! _run sudo umount "${mount_dir}" ; then
			_failure "Coffin file ${coffin_file} can not be umounted from ${mount_dir}"
		fi
	fi

		if is_luks_open "$mapper"; then
				if ! _run sudo cryptsetup close /dev/mapper/"${mapper}" ; then
			_failure "Coffin file $coffin_file can not be closed"
		fi
	else
		_verbose "Coffin file $coffin_file is already closed"
		return 0
	fi

		# Lock the identity's graveyard directory
		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
		IDENTITY_GRAVEYARD_PATH="${GRAVEYARD}/${GRAVEYARD_DIRECTORY_ENC}"
		_run sudo fscrypt lock "${IDENTITY_GRAVEYARD_PATH}"

		_set_active_identity # An empty  identity will trigger a wiping of the file

	_verbose "Coffin file $coffin_file has been closed"
}

list_coffins()
{
	local coffins_num=0
		local coffins

		ls_filtered=(ls -1 --ignore={dmroot,control,hush,pendev} --ignore='tomb*')

		if "${ls_filtered[@]}" &> /dev/null; then
		coffins=$("${ls_filtered[@]}" /dev/mapper)
				coffins_num=$(echo "$coffins" | wc -l)
	fi

	if [[ $coffins_num -gt 0 ]]; then
		_message "Coffins currently opened:"
				echo "$coffins" | xargs
		else
				_message "No opened coffins"
	fi
}

# src/lib/gpg.sh

# Create a RAMDisk and setup the GPG directory in it, with configuration files
init_gpg()
{
		_verbose 'Creating directory & setting permissions'
		rm -fR "${RAMDISK}"
		mkdir "${RAMDISK}"
		_run sudo mount -t tmpfs -o size=10m ramdisk "${RAMDISK}"
		_catch "Failed to mount tmp fs on ramdisk"
		sudo chown "${USER}" "${RAMDISK}"

		_catch "Failed to set ownership to ${RAMDISK}"
		sudo chmod 0700 "${RAMDISK}"

		_catch "Failed to change mod 0700 to ${RAMDISK}"

		_verbose "Testing ramdisk read/write"
		_verbose "$(mount | grep ramdisk)"
		_verbose "Previous command should look like this: \n\n\
				ramdisk on /home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n\
				ramdisk on /rw/home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n"

		touch "${RAMDISK}/delme" && rm "${RAMDISK}/delme"

		_catch "Failed to test write file ${1}"

		# Configuration files
		_verbose "Writing default GPG configuration file"
		cat >"${RAMDISK}/gpg.conf" <<EOF
# Avoid information leaked
no-emit-version
no-comments
export-options export-minimal

# Options for keys listing
keyid-format 0xlong
with-fingerprint
with-keygrip
with-subkey-fingerprint

# Displays the validity of the keys
list-options show-uid-validity
verify-options show-uid-validity

# Limits preferred algorithms
personal-cipher-preferences AES256
personal-digest-preferences SHA512
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed

# Options for asymmetric encryption
cipher-algo AES256
digest-algo SHA512
cert-digest-algo SHA512
compress-algo ZLIB
disable-cipher-algo 3DES
weak-digest SHA1

# Options for symmetric encryption
s2k-cipher-algo AES256
s2k-digest-algo SHA512
s2k-mode 3
s2k-count 65011712
EOF
}

# Create key pairs for a given identity, based on a premade batch file
gen_gpg_keys()
{
		local name="$1"
		local email="$2"
		local expiry="$3"
		local passphrase="$4"

		local expiry_date fingerprint

		# Output the identity batch file with values
		_verbose "Writing GPG batch file to ramdisk"
		cat >"${RAMDISK}/primary_key_unattended" <<EOF
%echo Generating EDDSA key (Ed25519 curve)
Key-Type: eddsa

Key-Curve: Ed25519

Key-Usage: sign
Key-Length: 4096
Name-Real: $name

Name-Email: $email

Expire-Date: 0
Passphrase: $GPG_PASS

%commit
%echo done
EOF

		# Generate key and get rid of batch file
		_verbose "Generating primary key from batch file"
		_run gpg --batch --gen-key "${RAMDISK}/primary_key_unattended"

		_catch "Failed to generate keys from batch file"
		_verbose "Deleting batch file"
		_run wipe -f -P 10 "${RAMDISK}/primary_key_unattended"

		_catch "Failed to wipe batch file: contains the identity passphrase"


		expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"

		fingerprint=$(gpg -K "${email}" | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')
		_message "Fingerprint: ${fingerprint}"

		local gpg_base_cmd=(gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key "${fingerprint}")

		_verbose "Generating encryption subkey-pair"
		echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" cv25519 encr "${expiry_date}" &> /dev/null
		_catch "Failed to generate encryption subkey-pair"

		_verbose "Generating signature subkey-pair"
		echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" ed25519 sign "${expiry_date}" &> /dev/null
		_catch "Failed to generate signature subkey-pair"

		_verbose "Generating authentication subkey-pair"
		echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" ed25519 auth "${expiry_date}" &> /dev/null
		_catch "subkeys" "Failed to generate authentication subkey-pair. Continuing still"

		_verbose "Directory structure:"
		_verbose "$(tree "${RAMDISK}")"
}

# A rather complete function performing several important, but quite unrelated, tasks:
# - Moves the GPG keyring of an identity into its coffin
# - Checks visually that files are where expected (if verbose flag set)
# - Removes the private keys from the keyring that is to be used daily
cleanup_gpg_init()
{
		local email="$1"

		local TMP_FILENAME TMP coffin_name

		# Filenames
		TMP_FILENAME=$(_encrypt_filename "${IDENTITY}-gpg")
		TMP="/tmp/${TMP_FILENAME}"
		coffin_name=$(_encrypt_filename "coffin-${IDENTITY}-gpg")

		# Making tmp directory
		_verbose "Creating temp directory and mounting coffin"
		mkdir "$TMP"
		sudo mount /dev/mapper/"${coffin_name}" "$TMP"

		_catch "Failed to mount coffin partition on $TMP"

		sudo chown "$USER" "$TMP"
		_verbose "Testing coffin filesystem"
		_verbose "$(mount | grep "$TMP_FILENAME")"

		_verbose "Copying GPG files in coffin"
		cp -fR "$RAMDISK"/* "$TMP" || _warning "Failed to copy one or more files into coffin"
		_verbose "Setting GPG files immutable"
		sudo chattr +i "$TMP"/private-keys-v1.d/*
		_verbose "Closing coffin"
		sudo chattr +i "$TMP"/openpgp-revocs.d/*
		sudo umount "$TMP" || _warning "Failed to unmount tmp directory $TMP"
		sudo cryptsetup close /dev/mapper/"$coffin_name"

		_catch "Failed to close LUKS filesystem for identity"

		# Clearing RAMDisk
		_verbose "Wiping and unmounting ramdisk"
		_run sudo wipe -rf "$RAMDISK"/*
		_catch "Failed to wipe $RAMDISK directory"
		sudo umount -l "$RAMDISK" || _warning "Failed to unmount ramdisk $RAMDISK"


		_verbose "Checking directory contents"
		_verbose "$(tree "$HUSH_DIR" "$GRAVEYARD")"
		_verbose "Should look like this:           \n\n \
/home/user/.hush                                    \n    \
		├── fjdri3kff2i4rjkFA (joe-gpg.key)             \n    \
/home/user/.graveyard                               \n    \
		├── fejk38RjhfEf13 (joe-gpg.coffin) \n"

		_verbose "Test opening and closing coffin for $IDENTITY"
		close_coffin
		open_coffin


		_verbose "Removing GPG private keys"

		local TOMB_SIZE KEYGRIP fingerprint

		TOMB_SIZE=15
		fingerprint=$(gpg -K "${email}" | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')

		# Creating tomb file for private keys and moving them
		_verbose "Creating tomb file for identity ${IDENTITY}"
		_run new_tomb "$GPG_TOMB_LABEL" $TOMB_SIZE "$IDENTITY"
		_verbose "Opening tomb file"
		_run open_tomb "$GPG_TOMB_LABEL" "$IDENTITY"

		KEYGRIP="$(gpg -K | grep Keygrip | head -n 1 | cut -d= -f 2 | sed 's/ //g').key"
		_verbose "Keygrip: $KEYGRIP"

		_verbose "Copying private data to tomb"
		_verbose "Private keys"
		cp "${RAMDISK}"/private-keys-v1.d/"${KEYGRIP}" "${HOME}"/.tomb/"${GPG_TOMB_LABEL}"/
		_verbose "Revocation certificates"
		cp "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev "${HOME}"/.tomb/"${GPG_TOMB_LABEL}"/

		# Deleting keys from keyring
		_verbose "Wiping corresponding files in GPG keyring"
		sudo chattr -i "${RAMDISK}"/private-keys-v1.d/"${KEYGRIP}"

		_run wipe -rf "${RAMDISK}"/private-keys-v1.d/"${KEYGRIP}" \
				|| _warning "Failed to delete master private key from keyring !"
		sudo chattr -i "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev
		_run wipe -rf "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev \
				|| _warning "Failed to delete master key revocation from keyring !"

		# Verbose checks
		_verbose "Printing GPG keyring. Should have 'sec#' instead of 'pub'"
		_verbose "$(gpg -K)"
		_verbose "Closing GPG tomb file"
		_run close_tomb "$GPG_TOMB_LABEL" "$IDENTITY"

		# Cleanup files
		rm -rf "$TMP"
}

# src/lib/identity.sh

# Upon unlocking a given identity, sets the name as an ENV

# variable that we can use in further functions and commands.
# $1 - The name to use. If empty, just resets the identity.
_set_active_identity ()
{
		# If the identity is empty, wipe the identity file
		if [[ -z ${1} ]] && [[ -e ${RISKS_IDENTITY_FILE} ]]; then
				identity=$(cat "${RISKS_IDENTITY_FILE}")
				_run wipe -s -f -P 10 "${RISKS_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

				_verbose "Identity '${identity}' is now inactive, (name file deleted)"
				_message "Identity '${identity}' is now INACTIVE"
				return
		fi

		# If we don't have a file containing the

		# identity name, populate it.
		if [[ ! -e ${RISKS_IDENTITY_FILE} ]]; then
				print "$1" > "${RISKS_IDENTITY_FILE}"
	fi

		_verbose "Identity '${1}' is now active (name file written)"
		_message "Identity '${1}' is now ACTIVE"
}

# Returns 0 if an identity is unlocked, 1 if not.
_identity_active ()

{
		local identity

		if [[ ! -e "${RISKS_IDENTITY_FILE}" ]]; then
				return 1
	fi

		identity=$(cat "${RISKS_IDENTITY_FILE}")
		if [[ -z ${identity} ]]; then
				return 1
		fi

		return 0
}

# Given an argument potentially containing the active identity, checks
# that either an identity is active, or that the argument is not empty.
# $1 - An identity name
# Exits the program if none is specified, or echoes the identity if found.
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
_identity_active_or_specified ()
{
		if [[ -z "${1}" ]] ; then
				if ! _identity_active ; then
						return 1
				fi
		fi

		# Print the identity
		if [[ -n "${1}" ]]; then
				print "${1}" && return
		fi

		print "$(cat "${RISKS_IDENTITY_FILE}")"
}

# _set_identity is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
#
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
_set_identity () {
		local identity="$1"

		# This will throw an error if we don't have an identity from any source.
		IDENTITY=$(_identity_active_or_specified "$identity")
		_catch "Command requires either an identity to be active or given as argument"

		# Then set the file encryption key for for it.
		FILE_ENCRYPTION_KEY=$(_set_file_encryption_key "$IDENTITY")
}

# src/lib/init.sh

# This file contains additional IDENTITY initialization functions.


init_pass ()

{
		local email="${1}"

		_verbose "Creating tomb file for pass"
		_run new_tomb "$PASS_TOMB_LABEL" 20 "$IDENTITY"
		_verbose "Opening password store"
		_run open_tomb "$PASS_TOMB_LABEL" "$IDENTITY"
		_verbose "Initializating password store with recipient $email"
		_run pass init "$email"
		_verbose "Closing pass tomb file"
		_run close_tomb "$PASS_TOMB_LABEL" "$IDENTITY"
}

# Creates a default management tomb in which, between others, the key=value store is being kept.
init_mgmt ()
{
		_verbose "Creating tomb file for management (key=value store, etc)"
		_run new_tomb "$MGMT_TOMB_LABEL" 10 "$IDENTITY"
		_verbose "Opening management tomb"
		_run open_tomb "$MGMT_TOMB_LABEL" "${IDENTITY}"
		_verbose "Closing management tomb"
		_run close_tomb "$MGMT_TOMB_LABEL" "$IDENTITY"
}

# store_risks_scripts copies the various vault risks scripts in a special directory in the
# hush partition, along with a small installation scriptlet, so that upon mounting the hush
# somewhere else, the user can quickly install and use the risks on the new machine.
store_risks_scripts ()
{
		local udev_rules="$1"

		_message "Copying risks scripts onto the hush partition"

		# Scripts/program
		mkdir -p "$RISKS_SCRIPTS_INSTALL_PATH"
		sudo cp "$(which risks)" "$RISKS_SCRIPTS_INSTALL_PATH"
		sudo chmod go-rwx "$RISKS_SCRIPTS_INSTALL_PATH"
		sudo cp /usr/local/share/zsh/site-functions/_risks "$RISKS_SCRIPTS_INSTALL_PATH"

		cat >"${RISKS_SCRIPTS_INSTALL_PATH}/install" <<'EOF'
#!/usr/bin/env zsh

local INSTALL_SCRIPT_DIR="${0:a:h}"
local INSTALL_SCRIPT_PATH="$0"
local BINARY_INSTALL_DIR="${HOME}/.local/bin"
local COMPLETIONS_INSTALL_DIR="${HOME}/.local/share/zsh/site-functions"


#
echo "Installing risks script in ${BINARY_INSTALL_DIR}"
if [[ ! -d "${BINARY_INSTALL_DIR}" ]]; then
		mkdir -p "${BINARY_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_PATH}" "${BINARY_INSTALL_DIR}"
sudo chmod go-rwx "${INSTALL_SCRIPT_PATH}"
sudo chmod u+x "${INSTALL_SCRIPT_PATH}"


#
echo "Installing risks completions in ${COMPLETIONS_INSTALL_DIR}"
if [[ ! -d "${COMPLETIONS_INSTALL_DIR}" ]]; then
		echo "Completions directory does not exist. Creating it."
		echo "You should add it to ${FPATH} and reload your shell"
		mkdir -p "${COMPLETIONS_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_DIR}/_risks" "${COMPLETIONS_INSTALL_DIR}"

echo "Done installing risks scripts."
EOF

		# Hush device udev rules: UUID is evaluated at format time here,
		# then installed onto the hush, so value freezed once and for all.
		cat >"${RISKS_SCRIPTS_INSTALL_PATH}/install_udev_rules" <<EOF
#!/bin/sh

# Maps this device ID to be automatically mounted as /dev/hush mapper.
${udev_rules}
EOF

		sudo chmod go-rwx "$RISKS_SCRIPTS_INSTALL_PATH/install_udev_rules"
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risks'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Simple way of setting the section and to update the padding
_in_section ()
{
		section="$1"
		if [[ -n "${2}" ]]; then
				section_padding="$2"
		fi
}


function is_verbose_set () {
		if [[ "${args[--verbose]}" -eq 1 ]]; then
				return 0
		else
				return 1
		fi
}

# Messaging function with pretty coloring
function _msg()

{
		# Check if we have been provided a section name,

		# and if not, that the section is set to a default.
		if [[ ${#@} -lt 3 ]]; then
				local progname="$section"
				if [[ -z "$progname" ]]; then
						progname='risks'
				fi
				local msg="$2"
		else
				local progname="$2"
				local msg="$3"
		fi

		# Padd the program/section name
		progname="$(printf %"${section_padding}"s "${progname}")"

		# Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

	local command="print -P"
	local pchars=""
	local pcolor="normal"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"; pchars=" > "; pcolor="yellow"
			;;
		message)
			pchars=" . "; pcolor="white"
			;;
		verbose)
			pchars="[D]"; pcolor="blue"
			;;
		success)
			pchars="(*)"; pcolor="green"
			;;
		warning)
			pchars="[W]"; pcolor="yellow"
			;;
		failure)
			pchars="[E]"; pcolor="red"
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		*)
			pchars="[F]"; pcolor="red"
			msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
			returncode=127
			;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

		# If there is a log-file specified with flag --log-file,
		# output the message to it, instead of the current file descriptor
		logfile="${args[--log-file]}"
		if [[ -n "${logfile}" ]]; then
				${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
				return $returncode
		fi

		# Else, print to stdout, with colors
	if [[ -t $fd ]]; then
			 [[ -n "$progname" ]] && progname="$fg[magenta]$progname$reset_color"
			 [[ -n "$pchars" ]] && pchars="$fg_bold[$pcolor]$pchars$reset_color"
			 msg="$fg[$pcolor]$msg$reset_color"
	fi

		${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _message() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
		option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose() {
		is_verbose_set && _msg verbose "$@"
	return 0
}

function _success() {
		option_is_set -q || _msg success "$@"
	return 0
}

function _warning() {
		option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()

{
	typeset -i exitcode=${exitv:-1}

		_msg failure "$@"
		if [[ -n "$COMMAND_STDERR" ]]; then
				_msg inline "$COMMAND_STDERR"
		fi

	# Be sure we forget the secrets we were told
		exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print() {
		option_is_set -q || _msg print "$@"
	return 0
}

# src/lib/mappers.sh
# Checks if the "hush partition" has been seen by kernel and returns 0 if true
is_named_partition_mapper_present()
{
		ls -1 "/dev/${1}" &> /dev/null
}

# Checks if the "hush partition" has been already decrypted and returns 0 if true
is_luks_mapper_present()
{
		ls -1 "/dev/mapper/${1}" &> /dev/null
}

# Checks if the "hush partition" is already mounted and returns 0 if true
is_hush_mounted()
{
	mount | grep "^/dev/mapper/${SDCARD_ENC_PART_MAPPER}" &> /dev/null
}

is_luks_open()
{
		ls "/dev/mapper/${1}" &> /dev/null
}

is_luks_mounted()
{
	mount | grep "^${1}" &> /dev/null
}

# Check if a *block* device is encrypted
# Synopsis: _is_encrypted_block /path/to/block/device
# Return 0 if it is an encrypted block device
is_encrypted_block() {
	local	 b=$1 # Path to a block device
	local	 s="" # lsblk option -s (if available)

	# Issue #163
	# lsblk --inverse appeared in util-linux 2.22
	# but --version is not consistent...
	lsblk --help | grep -Fq -- --inverse
	[[ $? -eq 0 ]] && s="--inverse"

		sudo lsblk $s -o type -n "$b" 2>/dev/null \
		| grep -e -q '^crypt$'
		# | egrep -q '^crypt$'

	return $?
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
		# The STDOUT/STDERR variables are populated, which
		# makes their content available to any subsequent call
		# to _failure, which needs STDERR output
		{
				IFS=$'\n' read -r -d '' COMMAND_STDERR;
				IFS=$'\n' read -r -d '' COMMAND_STDOUT;
				(IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
		} < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

		local ret="$?"

		# Output the command's result depending on the verbose mode
		# and if the command ran successfully. We check that either
		# stdout or stderr are non-empty: sometimes commands might
		# output to stderr, like wipe.
		if [[ $ret -eq 0 ]] && is_verbose_set ; then
				if [[ -n "$COMMAND_STDOUT" ]]; then
						_verbose "$COMMAND_STDOUT"
				fi
		fi

		# Return the command's exit code
		return $ret
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
		local ret="$?"

		if [[ ! $ret -eq 0 ]]; then
				_failure "$@"
		fi
}

# src/lib/secrets.sh

# _set_file_encryption_key is only called once per risks run,
# and does not need any password prompt to be used: it just generates
# a deterministic key based on known inputs.
_set_file_encryption_key ()
{
		local identity="$1"
		local key
		key=$(print "$identity" | spectre -q -n -s 0 -F n -t n -u "$identity" "$FILE_ENCRYPTION")
		print "$key"
}

# _encrypt_filename takes a filename as input, and uses the currently

# set identity to produce an random name to use as a file/directory name.
_encrypt_filename ()
{
		local filename="$1"
		local encrypted

		# -q            Quiet: just output the password/filename
		# -n            Don't append a newline to the password output
		# -s 0          Read passphrase from stdinput (fd 0)
		# -F n          No config file output
		# -t n          Output a nine characters name, without symbols
		# -u ${user}    User for which to produce the password/name
		encrypted=$(print "$FILE_ENCRYPTION_KEY" | spectre -q -n -s 0 -F n -t n -u "$IDENTITY" "$filename")
		print "${encrypted}"
}

# Returns a spectre-generated secret key, given a single name as argument.
# Uses the current IDENTITY as set by _set_identity <identity_name>
get_passphrase ()
{
		local passname="${1}"

		local passphrase

		# Forge command
		local cmd=(spectre -q -n -F n)
		local spectre_params=(-t K -P 512 -u "$IDENTITY" "$passname")

		passphrase=$("${cmd[@]}" "${spectre_params[@]}")

		print "$passphrase"
}

# src/lib/ssh.sh

# Generate SSH keypair and sets up scripts for loading multiple keypairs
gen_ssh_keys()
{
		local email="$1"

		_verbose "Creating and opening tomb file for SSH"
		_run new_tomb "$SSH_TOMB_LABEL" 20 "$IDENTITY"
		_run open_tomb "$SSH_TOMB_LABEL" "$IDENTITY"

		# Write multi-key loading script
		_verbose "Writing multiple SSH-keypairs loading script (ssh-add)"
		cat >"${HOME}/.ssh/ssh-add" <<'EOF'
#!/usr/bin/env bash
#
# Autostart SSH-agent and autoload all private keys in ~/.ssh directory
#
# How to use:
# - Place this scripts in ~/.bashrc. (We did not here, instead we use a .desktop autostart pointing to here).
# - If ssh-agent is not filled by any private keys, passphrase prompts will show up for each private keys
#

# register ssh key
env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
		(umask 077; ssh-agent >| "$env")
		. "$env" >| /dev/null ; }

agent_load_env

# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running
agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
		agent_start
		# this will load all private keys in ~/.ssh directory if agent not running
		find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
		# this will load all private keys in ~/.ssh directory if agent is not filled with any private key
		find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
fi

unset env
EOF
		chmod +x "${HOME}/.ssh/ssh-add" || _warning "Failed to make ssh-add custom script executable"

		# Generate keys
		_verbose "Generating keys for identity"
		_run ssh-keygen -t ed25519 -b 4096 -C "$email" -N "" -f "${HOME}"/.ssh/id_ed25519 # No passphrase
		_verbose "Making keys immutable"
		sudo chattr +i "${HOME}"/.ssh/id_ed25519*
		_verbose "Closing SSH tomb file"
		_run close_tomb "$SSH_TOMB_LABEL" "$IDENTITY"
}

# src/lib/store.sh

# print to stderr, red color
kv_echo_err() {
	echo -e "\e[01;31m$@\e[0m" >&2
}

# Usage: kv_validate_key <key>
kv_validate_key() {
	[[ "$1" =~ ^[0-9a-zA-Z._:-]+$  ]]
}

# Usage: kvget <key>
kvget() {
	key="$1"
	kv_validate_key "$key" || {
		_failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
	VALUE="$([ -f "$kv_user_dir/$key" ] && cat "$kv_user_dir/$key")"
	echo "$VALUE"

	[ "$VALUE" != "" ]
}

# Usage: kvset <key> [value]

kvset() {
	key="$1"
	value="$2"
	kv_validate_key "$key" || {
				_failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
	test -d "$kv_user_dir" || mkdir "$kv_user_dir"
	echo "$value" > "$kv_user_dir/$key"
		_message "${key} => ${value}"
}

# Usage: kvdel <key>
kvdel() {
	key="$1"
	kv_validate_key "$key" || {
				_failure "db" 'invalid param "key"'
		return 1
	}
	kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
	test -f "$kv_user_dir/$key" && rm -f "$kv_user_dir/$key"
		_message "Deleted key '${key}'"
}

# list all key/value pairs to stdout
# Usage: kvlist
kvlist() {
	kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
	for i in "$kv_user_dir/"*; do
		if [ -f "$i" ]; then
			key="$(basename "$i")"
			echo "$key" "$(kvget "$key")"
		fi
	done

}

# clear all key/value pairs in database
# Usage: kvclear
kvclear() {
		rm -rf "${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}"
}

# src/lib/tomb.sh

get_tomb_mapper()
{
	if ls -1 /dev/mapper/tomb.* &> /dev/null ;  then
				ls -1 /dev/mapper/tomb.* | grep "${1}"
	else
		echo "none"
	fi
}

# new_graveyard generates a private directory in the
# graveyard for a given identity, with fscrypt support.
new_graveyard ()
{
		local GRAVEYARD_DIRECTORY_ENC IDENTITY_GRAVEYARD_PATH

		# Always make sure the root graveyard directory exists
		if [[ ! -d ${GRAVEYARD} ]]; then
						_verbose "Creating directory $GRAVEYARD"
						mkdir -p "$GRAVEYARD"
		fi

		# The directory name in cleartext is simply the identity name
		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
		IDENTITY_GRAVEYARD_PATH="${GRAVEYARD}/${GRAVEYARD_DIRECTORY_ENC}"

		# Make the directory
		_verbose "Creating identity graveyard directory"
		mkdir -p "$IDENTITY_GRAVEYARD_PATH"

		# And setup fscrypt protectors on it.
		_verbose "Setting up fscrypt protectors on directory"
		echo "$FILE_ENCRYPTION_KEY" | sudo fscrypt encrypt "$IDENTITY_GRAVEYARD_PATH" \
			 --quiet --source=custom_passphrase --name="$GRAVEYARD_DIRECTORY_ENC"
}

# get_identity_graveyard returns the path to an identity's graveyard directory,
# and decrypts (gives access to) this directory, since this function was called
# because we need some resource stored within.
get_identity_graveyard ()
{
		local IDENTITY="$1"

		local GRAVEYARD_DIRECTORY_ENC IDENTITY_GRAVEYARD_PATH

		# Compute the directory names and absolute paths
		GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "${IDENTITY}")
		IDENTITY_GRAVEYARD_PATH="${GRAVEYARD}/${GRAVEYARD_DIRECTORY_ENC}"

		print "${IDENTITY_GRAVEYARD_PATH}"
}

# Generates a new tomb for a given identity
new_tomb()
{
		local LABEL="$1"
		local SIZE="$2"

		local TOMBID TOMBID_ENC TOMB_FILE

		local TOMB_KEY_FILE_ENC TOMB_KEY_FILE
		local uid RECIPIENT

		# Filenames
		TOMBID="${IDENTITY}-${LABEL}"
		TOMBID_ENC=$(_encrypt_filename "$TOMBID")

		TOMB_KEY_FILE_ENC=$(_encrypt_filename "${TOMBID}.key")
		TOMB_KEY_FILE="${HUSH_DIR}/${TOMB_KEY_FILE_ENC}"

		IDENTITY_GRAVEYARD_PATH=$(get_identity_graveyard "$IDENTITY")
		TOMB_FILE="${IDENTITY_GRAVEYARD_PATH}/${TOMBID_ENC}.tomb"

		# First make sure GPG keyring is accessible
		_verbose "Opening identity $IDENTITY"
		open_coffin

		# And get the email recipient
		uid=$(gpg -K | grep uid | head -n 1)
		RECIPIENT=$(echo "$uid" | grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b")

		# Then dig
		_verbose "Digging tomb in $TOMB_FILE"
		tomb dig -s "$SIZE" "$TOMB_FILE"

		_catch "Failed to dig tomb. Aborting"
		_run risks_hush_rw_command

		_verbose "Forging tomb key and making it immutable"
		tomb forge -g -r "$RECIPIENT" "$TOMB_KEY_FILE"

		_catch "Failed to forge keys. Aborting"
		sudo chattr +i "$TOMB_KEY_FILE"

		_verbose "Locking tomb with key"
		tomb lock -g -k "$TOMB_KEY_FILE" "$TOMB_FILE"

		_catch "Failed to lock tomb. Aborting"
		_run risks_hush_ro_command
}

# open_tomb requires a cleartext resource name that the function will encrypt to resolve the correct tomb file.
# The name is both used as a mount directory, as well as to determine when some special tombs need to be mounted
# on non-standard mount points, like gpg/ssh.
# $1 - Name of the tomb
# $2 - Identity
open_tomb()
{
	local RESOURCE="${1}"

		local TOMBID TOMBID_ENC TOMB_FILE

		local TOMB_KEY_FILE_ENC TOMB_KEY_FILE
		local mapper

		# Filenames
		TOMBID="${IDENTITY}-${RESOURCE}"
		TOMBID_ENC=$(_encrypt_filename "$TOMBID")

		TOMB_KEY_FILE_ENC=$(_encrypt_filename "$TOMBID.key")
		TOMB_KEY_FILE="${HUSH_DIR}/${TOMB_KEY_FILE_ENC}"

		IDENTITY_GRAVEYARD_PATH=$(get_identity_graveyard "$IDENTITY")
		TOMB_FILE="${IDENTITY_GRAVEYARD_PATH}/${TOMBID_ENC}.tomb"

		mapper=$(get_tomb_mapper "$TOMBID_ENC")

	case ${RESOURCE} in
		gpg)
			local mount_dir="${HOME}/.gnupg"
		;;
		pass)
			local mount_dir="${HOME}/.password-store"
		;;
		ssh)
			local mount_dir="${HOME}/.ssh"
		;;
		mgmt)
			local mount_dir="${HOME}/.tomb/mgmt"
		;;
		*)
			local mount_dir="${HOME}/.tomb/${RESOURCE}"
		;;
	esac

	# checks if the gpg coffin is mounted, and open it first:
		# this also have for effect to unlock the identity's graveyard.
		local COFFIN_NAME
		COFFIN_NAME=$(_encrypt_filename "coffin-${IDENTITY}-gpg")
	if ! is_luks_mounted "/dev/mapper/${COFFIN_NAME}" ; then
				open_coffin
	fi

	if [[ "${mapper}" != "none" ]]; then
				if is_luks_mounted "/dev/mapper/tomb.${TOMBID_ENC}" ; then
						_verbose "Tomb ${TOMBID} is already open and mounted"
			return 0
		fi
	fi

	if [[ ! -f "$TOMB_FILE" ]]; then
		_warning "No tomb file $TOMB_FILE found"
		return 2
	fi

		if [[ ! -f "$TOMB_KEY_FILE" ]]; then
				_warning "No key file $TOMB_KEY_FILE found"
		return 2
	fi

		# Make the mount point directory if needed
	if [[ ! -d ${mount_dir} ]]; then
				mkdir -p "$mount_dir"
	fi

		# And finally open the tomb
	tomb open -g -k "$TOMB_KEY_FILE" "$TOMB_FILE" "$mount_dir"
		_catch "Failed to open tomb"

		# Either add the only SSH key, or all of them if we have a script
	if [[ "$RESOURCE" == "ssh" ]]; then
				local ssh_add_script="${HOME}/.ssh/ssh-add"
				if [[ -e ${ssh_add_script} ]]; then
						${ssh_add_script}
				else
						ssh-add
				fi
	fi
}

close_tomb()
{
	local RESOURCE="${1}"

		# Filenames
		TOMBID="${IDENTITY}-${RESOURCE}"
		TOMBID_ENC=$(_encrypt_filename "${TOMBID}")

		if ! get_tomb_mapper "${TOMBID_ENC}" &> /dev/null ; then
		_verbose "Tomb ${IDENTITY}-${RESOURCE} is already closed"
		return 0
	fi

		# If the concatenated string is too long, cut it to 16 chars
		if [[ ${#TOMBID_ENC} -ge 16 ]]; then
				TOMBID_ENC=${TOMBID_ENC:0:16}
		fi

		# SSH tombs must all delete all SSH identities from the agent
	if [[ "${RESOURCE}" == "ssh" ]]; then
		_run ssh-add -D
	fi

		# Then close it
		tomb close "${TOMBID_ENC}"

		# And delete the directory if it's not a builtin
	case ${RESOURCE} in
		gpg|pass|ssh|signal|mgmt)
						# Ignore those
		;;
		*)
						rm -rf "${HOME}/.tomb/${RESOURCE}"
		;;
	esac
}

# Identical to close_tomb, but slamming it, so all processes making use of it are killed
slam_tomb()
{
	local RESOURCE="${1}"

		# Filenames
		# local FULL_LABEL="${IDENTITY}-${RESOURCE}"
		TOMBID="${IDENTITY}-${RESOURCE}"
		TOMBID_ENC=$(_encrypt_filename "${TOMBID}")

		if ! get_tomb_mapper "${TOMBID_ENC}" &> /dev/null ; then
		_verbose "Tomb ${IDENTITY}-${RESOURCE} is already closed"
		return 0
	fi

		# If the concatenated string is too long, cut it to 16 chars
		if [[ ${#TOMBID_ENC} -ge 16 ]]; then
				TOMBID_ENC=${TOMBID_ENC:0:16}
		fi

		# SSH tombs must all delete all SSH identities from the agent
		# before tombs kills the process.
	if [[ "${RESOURCE}" == "ssh" ]]; then
		_run ssh-add -D
	fi

		# Then close it
		tomb slam "${TOMBID_ENC}"

		# And delete the directory if it's not a builtin
	case ${RESOURCE} in
		gpg|pass|ssh|signal|mgmt)
						# Ignore those
		;;
		*)
						rm -rf "${HOME}/.tomb/${RESOURCE}"
		;;
	esac

}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Plays sounds
# Package `sox` provides the "play" program: sudo apt-get install sox
play_sound()
{
	if [ ${SDCARD_QUIET} -gt 0 ] || [ ! -x "$(command -v play)" ]; then
		return 1
	fi

	case $1 in

		plugged)
			if [ -f /usr/share/sounds/freedesktop/stereo/device-added.oga ]; then
				play -V0 /usr/share/sounds/freedesktop/stereo/device-added.oga &> /dev/null
			fi
		;;

		unplugged)

			if [ -f /usr/share/sounds/freedesktop/stereo/device-removed.oga ]; then
				play -V0 /usr/share/sounds/freedesktop/stereo/device-removed.oga &> /dev/null
			fi
		;;

		*)
			return 1
		;;
	esac
}

# src/lib/validations/format.sh
# validate_file_exists just checks that
validate_file_exists () {
		[[ -e "$1" ]] || echo "Invalid file $1: no such file or directory"
}

# Checks that a partition size given in absolute terms has a valid unit
validate_partition_size () {
		case "$1" in *K|*M|*G|*T|*P) return ;; esac
		echo "Absolute size must comprise a valid unit (K/M/G/T/P, eg. 100M)"
}

# Checks a given device path is encrypted.
validate_is_luks_device () {
		if ! is_encrypted_block  "$1" ; then
				echo "Path $1 seems not to be a LUKS filesystem."
		fi
}

# validate_device is general purpose validator that calls on many of the
# other validations above, because some commands will need all of the
# conditions above to be fulfilled.
validate_device () {

		# Check device file exists
		if [[ ! -e $1 ]]; then
				echo "Device path $1 does not exist: no such file."
		fi
}

# validate_identity_exists simply hashes an identity name and tries to
# find its corresponding coffin file in .graveyard/. If yes, the identity
# exists and is theoretically accessible on this system.
validate_identity_exists () {
		local identity="$1"

		# This might be empty if none have been found, since the _failure
		# call in _identity_active_or_specified is executed in a subshell.
		# We don't care.
		IDENTITY=$(_identity_active_or_specified "$identity")
		FILE_ENCRYPTION_KEY=$(_set_file_encryption_key "$IDENTITY")

		# Stat the coffin
		local coffin_filename coffin_file
		coffin_filename=$(_encrypt_filename "${IDENTITY}-gpg.coffin")
		coffin_file="${GRAVEYARD}/${coffin_filename}"

		if [[ ! -e $coffin_file ]]; then
				echo "Invalid identity $1: no corresponding coffin file found in ~/.graveyard"
		fi
}

# :command.command_functions

# :command.function
risks_hush_mount_command() {
	# src/hush_mount_command.sh

	if ! is_named_partition_mapper_present "${SDCARD_ENC_PART_MAPPER}" ; then
			_failure "Device mapper /dev/${SDCARD_ENC_PART_MAPPER} not found.\n\
		Be sure you have attached your hush partition.       "
	fi

	if is_hush_mounted ; then
			_message "Sdcard already mounted"
			play_sound
			return 0
	fi

	if ! is_luks_mapper_present "${SDCARD_ENC_PART_MAPPER}" ; then
			# decrypts the "hush partition": it will ask for passphrase
			if ! sudo cryptsetup open --type luks "${SDCARD_ENC_PART}" "${SDCARD_ENC_PART_MAPPER}" ; then
					_failure "The hush partition ${SDCARD_ENC_PART} can not be decrypted"
			fi
	fi

	# creates the "hush partition" mount point if it doesn't exist
	if [ ! -d "${HUSH_DIR}" ]; then
			mkdir -p "${HUSH_DIR}" &> /dev/null
	fi

	# mounts the "hush partition" in read-only mode by default
	if ! sudo mount -o ro "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" ; then
			_failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be mounted on ${HUSH_DIR}"
	fi

	play_sound "plugged"

	echo
	_success "SDCARD has been mounted read-only. To give write permissions, use:"
	_success "risks hush rw"
	echo

}

# :command.function
risks_hush_rw_command() {
	# src/hush_rw_command.sh
	if ! is_hush_mounted ; then
							_failure "SDCARD is not mounted"
			exit 1
	fi

	mount_option="remount,rw"
	if ! sudo mount -o ${mount_option} "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" &> /dev/null ; then
			_failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with write permissions"
			exit 1
	fi

	sudo chown "${USER}" "${HUSH_DIR}"

	_warning "/----------------------------------------/"
	_message -n "Warning! HUSH is writable              \n"
	_message -n "Do not unplug without umounting it !   \n"
	_message -n "/----------------------------------------/ \n"

}

# :command.function
risks_hush_ro_command() {
	# src/hush_ro_command.sh
	if ! is_hush_mounted ; then
			_failure "HUSH is not mounted"
	fi

	mount_option="remount,ro"
	if ! sudo mount -o ${mount_option} "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" &> /dev/null ; then
			_failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with read-only permissions"
	fi

	_message "HUSH is now mounted read-only"

}

# :command.function
risks_hush_umount_command() {
	# src/hush_umount_command.sh

	if ! is_named_partition_mapper_present "${SDCARD_ENC_PART_MAPPER}" ; then
			_failure "Device mapper /dev/mapper/${SDCARD_ENC_PART_MAPPER} not found.\n \
			Be sure you have attached your hush partition."
	fi

	if is_hush_mounted ; then
			if ! sudo umount -f "${HUSH_DIR}" ; then
					_failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be umounted from ${HUSH_DIR}"
			fi
	fi

	if is_luks_mapper_present "${SDCARD_ENC_PART_MAPPER}" ; then
			if ! sudo cryptsetup close "${SDCARD_ENC_PART_MAPPER}" ; then
					_failure "SDCARD can not be closed"
			fi
	fi

	play_sound "unplugged"

	_message "Hush device is unmounted and closed"

}

# :command.function
risks_hush_format_command() {
	# src/hush_format_command.sh
	# Easily cleanup, format, luks-encrypt and filesystem setup onto an SDCard
	# to be used as a store for the various identities' data (excluding backup).
	# $1 - The device file to the SDCard (raw device, not partition, eg. /dev/sda, not /dev/sda1)
	# $2 - The size for the encrypted partition, either absolute or relative, to pass to the fdisk command.

	sd_drive="${args[device]}"        # Device file

	sd_ext4_drive="$sd_drive"1        # Dumb partition
	sd_enc_part="$sd_drive"2          # Encrypted partition
	mount_point="${HUSH_DIR}"

	# Sizes: by default 90% of the drive is used as encrypted partition,
	# but flag --percent-size or --absolute-size can modify size.
	# If absolute size was specified, use it and forget all other values
	if [[ -n "${args[--size-absolute]}" ]]; then
			enc_part_size="${args[--size-absolute]}"
			start_enc_sectors="${enc_part_size}"
	else
			percent_size="${args[--size-percent]}"

			total_size="$(sudo blockdev --getsize "${sd_drive}")"
			enc_part_size="$(( total_size * percent_size / 100 ))"
			start_enc_sectors="$(( total_size - enc_part_size - 2048 ))"
	fi

	# Cleanup & making partitions

	_message "Overwriting and partitioning SDCARD"
	_verbose "Cleaning drive"
	 sudo dd if=/dev/urandom of="${sd_drive}" bs=1M status=progress && sync

	_message "Creating partitions"

	nl=$'\n' # Needed because EOF does not preserve some newlines.
	_run sudo fdisk -u "${sd_drive}" <<-EOF
	n
	p
	1

	+${start_enc_sectors}
	n
	p
	2

	$nl
	w

	EOF
	_catch "Failed to format partitions"

	# Automounting the first partition on any OS
	_verbose "Making 1st partition mountable by default for all OS (fat32)"
	_run sudo mkfs.vfat -F 32 -n DATA "${sd_ext4_drive}"

	_catch "Failed to make vfat32 filesystem"

	# Hush partition encryption setup

	mkdir "${mount_point}" &> /dev/null
	_message "Creating LUKS filesystem"
	sudo cryptsetup -v -q -y --cipher aes-xts-plain64 --key-size 512 --hash sha512 \
			--iter-time 5000 --use-random luksFormat "$sd_enc_part"
	_catch "Failed to format drive with LUKS"

	_verbose "Checking LUKS partition status"
	sudo cryptsetup open --type luks "${sd_enc_part}" "${SDCARD_ENC_PART_MAPPER}"

	_catch "Failed to open LUKS drive"
	_verbose "$(sudo cryptsetup status "${SDCARD_ENC_PART_MAPPER}")"

	# Ext4 with encryption support (for fscrypt) and fscrypt setup
	_message "Making filesytem and setting up high-level encryption (fscrypt)"
	_run sudo mkfs.ext4 -m 0 -L "hush" "/dev/mapper/${SDCARD_ENC_PART_MAPPER}"

	_catch "Failed to make ext4 filesystem on partition"
	_run sudo /sbin/tune2fs -O encrypt "/dev/mapper/${SDCARD_ENC_PART_MAPPER}"

	_catch "Failed to enable encryption on ext4 filesystem"
	_run sudo mount -o rw "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${mount_point}"

	_catch "Failed to mount partition on ${mount_point}"

	sudo chown "${USER}" "${HUSH_DIR}"
	_verbose "Setting up fscrypt in hush mount point (${mount_point})"
	sudo fscrypt setup --quiet --force "${mount_point}"
	_catch "Failed to setup fscrypt metadata with root permissions"

	# Checks
	_verbose "$(mount | grep "${SDCARD_ENC_PART_MAPPER}")"
	_verbose "Last command should give the following result:                     \n \
			/dev/mapper/hush on /home/user/.hush type ext4 (rw,relatime,data=ordered)       \n \
			/dev/mapper/hush on /rw/home/user/.hush type ext4 (rw,relatime,data=ordered)    \n\n"

	# Prepare a udev command string with correct UUID, to be written

	# both on this system and on the hush if used on another computer.
	_message "Setting Udev rules for hush partition "

	UUID=$(sudo cryptsetup luksUUID "${sd_enc_part}")
	local udev_rules='echo SUBSYSTEM==\"block\", ENV{ID_FS_UUID}==\"'${UUID}'\", SYMLINK+=\"hush\" > /etc/udev/rules.d/99-sdcard.rules'

	# Write our risks scripts in a special directory on the hush, and close the device.
	store_risks_scripts "$udev_rules"

	# Note that even if we fail to umount at $mount_point, we still try to cryptsetup close hush.
	_verbose "Closing and unmounting device"
	_run sudo umount "${mount_point}"

	_catch "Failed to unmount ${mount_point}"

	_run sudo cryptsetup close "${SDCARD_ENC_PART_MAPPER}"

	_catch "Failed to close LUKS filesystem on ${SDCARD_ENC_PART_MAPPER}"

	# Setup udev identitiers mapping for hush partition

	_message "Setting Udev rules for hush partition "

	sudo sh -c "${udev_rules}"
	_catch "Failed to write udev mapper file with SDCard UUID"
	_verbose "Restarting udev service"

	sudo udevadm control --reload-rules
	_success "Successfully formatted and prepared SDcard as hush device"

}

# :command.function
risks_backup_mount_command() {
	# src/backup_mount_command.sh

	PENDRIVE="${args[backup_device]}"

	# If we already have a device mounted as backup, fail.
	if ls -1 /dev/mapper/"${BACKUP_MAPPER}" &> /dev/null; then
			_message "Backup device is already mounted"
			play_sound
			return 0
	fi

	if [[ ! -d $BACKUP_MOUNT_DIR ]]; then
			_verbose "Creating mount point directory $BACKUP_MOUNT_DIR"
			mkdir "$BACKUP_MOUNT_DIR" &> /dev/null
			_verbose "Changing directory owner to $USER"
			sudo chown "$USER" "$BACKUP_MOUNT_DIR"
	fi

	_verbose "Opening LUKS pendrive"
	sudo cryptsetup open --type luks "$PENDRIVE" "$BACKUP_MAPPER"
	_catch "Failed to open LUKS pendrive. Aborting"
	sudo mount /dev/mapper/"${BACKUP_MAPPER}" "$BACKUP_MOUNT_DIR"

	_message "Backup unlocked and mounted on ${BACKUP_MOUNT_DIR}"

}

# :command.function
risks_backup_umount_command() {
	# src/backup_umount_command.sh
	#

	if [[ -e "$BACKUP_MOUNT_DIR" ]] ; then
			if ! sudo umount -f "${BACKUP_MOUNT_DIR}" ; then
					_failure "/dev/mapper/${BACKUP_MAPPER} can not be umounted from ${BACKUP_MOUNT_DIR}"
			fi
	fi

	if is_luks_mapper_present "${BACKUP_MAPPER}" ; then
			if ! sudo cryptsetup close "${BACKUP_MAPPER}" ; then
					_failure "Backup LUKS can not be closed"
			fi
	fi

	play_sound "unplugged"

	_message "Backup device is umounted and closed"

}

# :command.function
risks_backup_format_command() {
	# src/backup_format_command.sh
	# Easily cleanup, format, luks-encrypt and filesystem setup for a USB drive
	# to be used as a backup medium for risks data.

	PENDRIVE="${args[device]}"

	_message "Formatting and encrypting backup drive"

	# Data cleanup
	_verbose "Overwriting drive data"
	sudo dd if=/dev/urandom of="${PENDRIVE}" bs=1M status=progress && sync

	# Encryption setup
	_message "Setting up LUKS on drive"
	sudo cryptsetup -v -q -y --cipher aes-xts-plain64 --key-size 512 \
			--hash sha512 --iter-time 5000 --use-random luksFormat "${PENDRIVE}"
	_catch "Failed to setup LUKS filesystem on backup drive"

	# Filesystem setup
	mkdir "${BACKUP_MOUNT_DIR}" &> /dev/null
	sudo cryptsetup open --type luks "${PENDRIVE}" "${BACKUP_MAPPER}"

	_catch "Failed to open backup LUKS filesystem"

	_message "Making ext4 filesystem on LUKS mapper"
	_run sudo mkfs.ext4 -m 0 -L "backup" /dev/mapper/"${BACKUP_MAPPER}"

	_catch "Failed to make ext4 filesystem on backup"

	# fsencrypt setup
	_message "Enabling filesystem encryption and setting up fscrypt"
	_run sudo /sbin/tune2fs -O encrypt "/dev/mapper/${BACKUP_MAPPER}"

	_catch "Failed to enable encryption on ext4 filesystem"

	_run sudo mount /dev/mapper/"${BACKUP_MAPPER}" "${BACKUP_MOUNT_DIR}"

	_catch "Failed to mount partition on ${BACKUP_MOUNT_DIR}"
	sudo chown "${USER}" "${BACKUP_MOUNT_DIR}"

	_message "Setting up fscrypt in backup mount point (${BACKUP_MOUNT_DIR})"
	echo "N" | sudo fscrypt setup "${BACKUP_MOUNT_DIR}" &> /dev/null
	_catch "Failed to setup fscrypt metadata with root permissions"

	# Closing
	_message "Unmounting backup pendrive"
	risks_backup_umount_command
	_catch "Failed to correctly unmount backup device"

	_success "Done formatting and encrypting backup drive"
	_success "Use 'risks backup mount' to get read-write access"

}

# :command.function
risks_backup_identity_command() {
	# src/backup_identity_command.sh

	local BACKUP_GRAVEYARD_ROOT="${BACKUP_MOUNT_DIR}/graveyard"

	local IDENTITY_GRAVEYARD_PATH IDENTITY_BACKUP_GRAVEYARD_PATH GRAVEYARD_DIRECTORY_ENC

	GRAVEYARD_DIRECTORY_ENC=$(_encrypt_filename "$IDENTITY")
	IDENTITY_GRAVEYARD_PATH="${GRAVEYARD}/${GRAVEYARD_DIRECTORY_ENC}"
	IDENTITY_BACKUP_GRAVEYARD_PATH="${BACKUP_GRAVEYARD_ROOT}/${GRAVEYARD_DIRECTORY_ENC}"

	# Ensure a backup is mounted
	if ! is_luks_mapper_present "$BACKUP_MAPPER" ; then
			_failure "No mounted backup medium found. Mount one with risks backup mount </dev/device>"
	fi

	# Ensure we have an active identity, which will be detected in this call
	if ! _identity_active ; then
			_failure "This command requires an identity to be active"
	fi

	_message "Backing up current identity data and hush partition"

	echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$IDENTITY_BACKUP_GRAVEYARD_PATH" --quiet

	# Backup the GPG coffin for this identity
	_verbose "Backing GPG"

	_run backup_identity_gpg "${BACKUP_MOUNT_DIR}/graveyard"

	# Graveyard backup for this identity.
	_verbose "Backing graveyard files"
	_run sudo chattr -i "${IDENTITY_BACKUP_GRAVEYARD_PATH}"/* \
			|| _verbose "No files in backup/graveyard for which to change immutability properties"
	_run cp -fR "${IDENTITY_GRAVEYARD_PATH}"/* "${IDENTITY_BACKUP_GRAVEYARD_PATH}"
	_catch "Failed to copy graveyard files to backup medium"
	_verbose "Making graveyard backup files immutable"

	# Testing the full backup

	_verbose "Printing directory tree in identity backup graveyard"
	_verbose "$(tree "$IDENTITY_BACKUP_GRAVEYARD_PATH")"

	# We don't need the identity backup graveyard anymore, lock it
	_run sudo fscrypt lock "${IDENTITY_BACKUP_GRAVEYARD_PATH}"

	# And backup hush, since it has new content
	risks_backup_hush_command

	_message "Done backing current identity and hush device"

}

# :command.function
risks_backup_hush_command() {
	# src/backup_hush_command.sh

	# if backup is not found, fail and ask to mount
	if ! is_luks_mapper_present "$BACKUP_MAPPER" ; then
			_failure 'Backup device not mounted. Please mount with `risks backup mount DEVICE`'
	fi

	_message "Backing hush partition"

	_verbose "Unmounting hush partition"
	risks_hush_umount_command

	if [[ -e ${BACKUP_MOUNT_DIR}/hush.img ]]; then
			sudo chattr -i "${BACKUP_MOUNT_DIR}"/hush.img
	fi
	sudo dd if=/dev/hush of="${BACKUP_MOUNT_DIR}/hush.img" status=progress bs=16M
	sudo chattr +i "${BACKUP_MOUNT_DIR}/hush.img" || _warning "No hush.img file found after dd operation"

	_message "Done backing hush partition"

}

# :command.function
risks_new_identity_command() {
	# src/new_identity_command.sh

	local name identity expiry pendrive pendrive_error email

	# Base identity parameters, set globally.
	name="${args[name]}"
	expiry="${args[expiry_date]}"

	identity="${name// /_}"
	email="${args[email]}"

	# Base filesystem parameters
	pendrive="${args[backup_device]}"

	# Pre-run checks =============================================================

	# No identity should be active, because some important mount points will be
	# unaccessible or might risk ending in a dangling state.
	if _identity_active ; then
			_failure "An identity seems to be active. Cannot safely create a new one."
	fi

	# Check the path to the backup drive is a LUKS device.
	pendrive_error=$(validate_device "$pendrive")
	if [[ -n $pendrive_error ]]; then

			_failure "Device file $pendrive seems not to be a LUKS filesystem."
	fi

	# Check the hush device is, if mounted, on a read-only state at this point.
	# We fail if it's read-write, because we should assume another process is
	# currently writing to it.
	if is_hush_mounted && [[ -w "$HUSH_DIR" ]]; then
			_failure "Hush is currently mounted read-write. \n \
		 Please ensure nothing is writing to it and set it to read-only first"
	fi

	# Start work =================================================================

	_in_section 'risks' 6
	_message "Starting new identity generation process"
	_warning "Do not unplug hush and backup devices during the process"

	# Use the identity name to set its file encryption key.
	# This call propagates some of those essential variables

	# so that all functions can use them.
	_set_identity "$identity"

	# GPG

	#
	_in_section 'gpg' && _message "Setting up RAMDisk and GPG backend"
	init_gpg

	# Generate GPG keypairs with a different passphrase than the one
	# we use for encrypting file/directory names and contents.
	_message "Generating GPG keys"

	# This new key is also the one provided when using gpgpass command.
	GPG_PASS=$(get_passphrase "$GPG_TOMB_LABEL")
	echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
	_warning "GPG passphrase copied to clipboard with one-time use only"
	_message -n "Copy it in the coming GPG prompt when creating builtin tombs\n"

	_run gen_gpg_keys "$name" "$email" "$expiry"

	# Setup the identity graveyard directory with fscrypt protection
	_in_section 'coffin' && _message "Creating and setting encrypted identity directory"
	new_graveyard

	# At this point, we need access to the hush device, so make sure

	# it's mounted and that we have read-write permissions.
	_in_section 'hush' && _message "Mounting hush device with read-write permissions"
	risks_hush_mount_command
	_run risks_hush_rw_command

	# Then only, generate the coffin and copy it into the root graveyard
	# (not the identity's graveyard subdirectory, because we need access to
	# this file BEFORE anything else, since it contains the GPG keyring)
	_in_section 'coffin' && _message "Creating and testing GPG coffin container"
	gen_coffin

	# Cleaning RAM disk, removing private keys from the keyring and test open/close

	_in_section 'gpg' && _message "Cleaning and backing keyring privates"
	cleanup_gpg_init "$email"

	#
	_in_section 'ssh' && _message "Generating SSH keypair and multi-key ssh-agent script"

	gen_ssh_keys "$email"

	_in_section 'pass' && _message "Initializing password-store"
	init_pass "$email"


	# config files, etc, and set default key=values
	_in_section 'mgmt' && _message "Generating management tomb"
	init_mgmt

	# for the enrypted data directory in the Signal VM.
	_in_section 'signal' && _message "Generating Signal messenger tomb"
	_run new_tomb "$SIGNAL_TOMB_LABEL" 20

	#
	_in_section 'backup' && _message "Setting identity backup and making initial one"

	risks_backup_mount_command
	_catch "failed to decrypt and mount backup drive"

	# Some setup is needed for this identity to have access to its backup
	_verbose "Setting graveyard backup for this identity"
	_run setup_identity_backup
	_catch "Failed to setup identity backup graveyard"

	# And then actually back it up
	risks_backup_identity_command
	_catch "Failed to correctly backup data"

	risks_backup_umount_command


	echo && _success "risks" "Identity generation complete." && echo

}

# :command.function
risks_new_tomb_command() {
	# src/new_tomb_command.sh

	LABEL="${args[tomb_name]}"
	SIZE="${args[size]}"

	# We need the hush device, on which to save the key
	if ! is_luks_mapper_present "${SDCARD_ENC_PART_MAPPER}" ; then
			_failure "Hush device not mounted. Need access to write tomb key in it."
	fi

	_set_identity "${args[identity]}"

	_message "Creating tomb $LABEL with size ${SIZE}M"

	# This new key is also the one provided when using gpgpass command.
	GPG_PASS=$(get_passphrase "$GPG_TOMB_LABEL")
	echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
	_warning "GPG passphrase copied to clipboard with one-time use only"
	_message -n "Copy it in the coming GPG prompt when creating the tomb.\n"

	_run new_tomb "$LABEL" "$SIZE"
	_catch "Failed to create tomb"

	_message "Done creating tomb."

}

# :command.function
risks_open_command() {
	# src/open_command.sh
	# The open_command file is essentially a wrapper around several library
	# functions, depending on the type of store the user wants to open.

	resource="${args[resource]}"

	_set_identity "${args[identity]}"

	# Either only open the GPG keyring.
	if [[ "$resource" == "gpg" ]] || [[ "$resource" == "coffin" ]]; then
			# We need to identity argument to be non-nil
			if [[ -z $IDENTITY ]]; then
					_failure "The IDENTITY argument was not specified"
			fi

			_message "Opening coffin and mounting GPG keyring"

			open_coffin
			exit $?
	fi

	# Then derive the gpg pass phrase from it, with one-time use,
	# needed for all tombs, no matter how many.
	GPG_PASS=$(get_passphrase "$GPG_TOMB_LABEL")
	echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
	_warning "GPG passphrase copied to clipboard with one-time use only"

	# Bulk load
	if [[ "$resource" == "identity" ]]; then

			_message "Opening coffin and mounting GPG keyring"
			open_coffin

			_message "Opening Management tomb ... "
			_run open_tomb "$MGMT_TOMB_LABEL"

			_message "Opening SSH tomb ... "
			_run open_tomb "$SSH_TOMB_LABEL"

			_message "Opening PASS tomb ..."
			_run open_tomb "$PASS_TOMB_LABEL"

			_message "Opening Signal tomb ..."
			_run open_tomb "$SIGNAL_TOMB_LABEL"

			exit 0
	fi

	# Or open a single tomb
	open_tomb "$resource" "$IDENTITY"

}

# :command.function
risks_close_command() {
	# src/close_command.sh

	resource="${args[resource]}"

	_set_identity "${args[identity]}"

	# Either only close the GPG keyring and coffin
	if [[ "$resource" == "gpg" ]] || [[ "$resource" == "coffin" ]]; then
			_message "Closing coffin and GPG keyring"
			close_coffin
			exit $?
	fi

	# Or close everything
	if [[ "$resource" == "identity" ]]; then
			_message "Closing Signal tomb ..."
			_run close_tomb "$SIGNAL_TOMB_LABEL"

			_message "Closing PASS tomb ..."
			_run close_tomb "$PASS_TOMB_LABEL"

			_message "Closing SSH tomb ..."
			_run close_tomb "$SSH_TOMB_LABEL"

			_message "Closing Management tomb ..."
			_run close_tomb "$MGMT_TOMB_LABEL"

			# Finally, find all other tombs...
			tombs=$(tomb list 2>&1 \
					| sed -n '0~4p' \
					| awk -F" " '{print $(3)}' \
					| rev | cut -c2- | rev | cut -c2-)

			# ... and close them
			while read -r tomb_name ; do
					if [[ -z $tomb_name ]]; then
							continue
					fi

					_message "Closing tomb $tomb_name ..."
					_run tomb close "$tomb_name"
			done <<< "$tombs"

			_message "Closing GPG coffin ..."
			close_coffin
			exit 0
	fi

	# Or just a tomb
	close_tomb "$resource"
	exit $?

}

# :command.function
risks_list_command() {
	# src/list_command.sh

	resource="${args[resource]}"

	if [[ -z $resource ]]; then
			list_coffins
			echo
			_message "Tombs currently opened:"
			tomb list
			exit $?
	fi

	if [[ "${resource}" == "coffins" ]]; then
			list_coffins
			exit $?
	fi

	if [[ "${resource}" == "tombs" ]]; then
			_message "Tombs currently opened:"
			tomb list
			exit $?
	fi

	_failure "Unknown resource ${resource}"

}

# :command.function
risks_slam_command() {
	# src/slam_command.sh

	# First set the identity variables with the active one.

	_set_identity ""

	_warning "risks" "Slaming identity $IDENTITY"

	_run slam_tomb "$SIGNAL_TOMB_LABEL"

	_message "Slaming PASS tomb ..."
	_run slam_tomb "$PASS_TOMB_LABEL"

	_message "Slaming SSH tomb ..."
	_run slam_tomb "$SSH_TOMB_LABEL"

	_message "Slaming Management tomb ..."
	_run slam_tomb "$MGMT_TOMB_LABEL"

	_message "Closing GPG coffin ..."
	close_coffin
	# done

	# Finally, find all other tombs...
	tombs=$(tomb list 2>&1 \
			| sed -n '0~4p' \
			| awk -F" " '{print $(3)}' \
			| rev | cut -c2- | rev | cut -c2-)

	# ... and close them
	while read -r tomb_name ; do
			_message "Slaming tomb $tomb_name ..."
			_run tomb slam "$tomb_name"
	done <<< "$tombs"

	# 3 - Unmount hush
	echo
	_message "Unmounting hush partition"
	_run risks_hush_umount_command
	_catch "Failed to unmount hush partition"

	_message "Umounting backup device"
	_run risks_backup_umount_command
	_catch "Failed to umount backup device"

}

# :command.function
risks_gpgpass_command() {
	# src/gpgpass_command.sh
	# gpgpass essentially wraps a call to spectre with our identity parameters.
	# Note that this function cannot fail because of "a wrong password".
	#
	# If a second, non-nil argument is passed, we print the passphrase:

	# this is used when some commands need both the passphrase as an input
	# to decrypt something (like files) and the user needs them for GPG prompts

	declare TIMEOUT

	# Identity is optionality specified as an argument
	_set_identity "${args[identity]}"

	# Since we did not give any input (master) passphrase to this call,
	# spectre will prompt us for an input one. This input is already known
	# to us, since we have used the same when generating the GPG keys.
	#
	# In addition: this call cannot fail because of "a wrong" passphrase.
	# It will just output something, which will or will not (if actually incorrect)
	# work when pasted in further GPG passphrase prompts.
	GPG_PASS=$(get_passphrase "$GPG_TOMB_LABEL")

	TIMEOUT="${args[--timeout]-$GPGPASS_TIMEOUT}"

	echo -n "$GPG_PASS" | xclip -selection clipboard
	( sleep "$TIMEOUT"; echo -n "" | xclip -selection clipboard;) &

	_message "The passphrase has been saved in clipboard"
	_message "Press CTRL+SHIFT+C to share the clipboard with another qube."
	_message "Local clipboard will be erased is $TIMEOUT seconds"

}

# :command.function
risks_load_command() {
	# src/load_command.sh

	RESOURCE="${args[resource]}"   # Resource is a tomb file (root directory) in ~/.tomb
	DEST_VM="${args[dest_vm]}"

	_set_identity "${args[identity]}"

	# Open the related tomb for the tool

	_run open_tomb "$RESOURCE"
	_catch "Failed to open tomb"

	# Get the source directory, and copy the files to the VM
	_message "Loading data in tomb $RESOURCE to VM $DEST_VM"
	local source_dir="${HOME}/.tomb/${RESOURCE}"
	_message "$(qvm-copy-to-vm "$DEST_VM" "${source_dir}/"'*')"

	# And close tomb if asked to
	if [[ "${args[--close-tomb]}" -eq 1 ]]; then
			_message "Closing tomb"
			_run close_tomb "$RESOURCE"
	fi

}

# :command.function
risks_save_command() {
	# src/save_command.sh

	SOURCE_VM="${args[source_vm]}"

	RESOURCE="${args[resource]}"   # Resource is a tomb file (root directory) in ~/.tomb

	_set_identity "${args[identity]}"

	local source_dir dest_dir

	# Make the source directory

	# Don't do anything if the directory does not exist
	source_dir="${HOME}/QubesIncoming/${SOURCE_VM}"
	if [[ ! -d $source_dir ]]; then
			_failure "No QubesIncoming directory found for $SOURCE_VM"
	fi

	# Open the related tomb for the tool

	_run open_tomb "$RESOURCE"
	_catch "Failed to open tomb"

	# And make the destination directory
	dest_dir="${HOME}/.tomb/${RESOURCE}"

	# Or move the data from the directory to the tomb directory
	_message "Moving data to tomb $RESOURCE directory"
	mv "${source_dir}/"'*' "$dest_dir"

	# And close tomb if asked to
	if [[ "${args[--close-tomb]}" -eq 1 ]]; then
			_message "Closing tomb"
			_run close_tomb "$RESOURCE"
	fi

}

# :command.function
risks_kv_set_command() {
	# src/kv_set_command.sh
	KEY="${args[key]}"
	VALUE="${args[value]}"

	kvset "${KEY}" "${VALUE}"

}

# :command.function
risks_kv_get_command() {
	# src/kv_get_command.sh
	KEY="${args[key]}"

	kvget "${KEY}"

}

# :command.function
risks_kv_unset_command() {
	# src/kv_unset_command.sh
	KEY="${args[key]}"

	kvdel "${KEY}"

}

# :command.function
risks_kv_list_command() {
	# src/kv_list_command.sh
	_message "Saved keys:"

	kvlist

}

# :command.function
risks_kv_clean_command() {
	# src/kv_clean_command.sh
	_message "Clearing all keys for the store"

	kvclear

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--version | -v )
		version_command
		exit
		;;

	--help | -h )
		long_usage=yes
		risks_usage
		exit
		;;

	esac

	# :command.environment_variables_filter
	export SDCARD_ENC_PART="${SDCARD_ENC_PART:-/dev/hush}"
	export SDCARD_ENC_PART_MAPPER="${SDCARD_ENC_PART_MAPPER:-hush}"
	export SDCARD_QUIET="${SDCARD_QUIET:-0}"
	export HUSH_DIR="${HUSH_DIR:-/home/user/.hush}"
	export GRAVEYARD="${GRAVEYARD:-/home/user/.graveyard}"
	export BACKUP_MAPPER="${BACKUP_MAPPER:-pendev}"

	# :command.dependencies_filter
	if ! [[ -x "$(command -v wipe)" ]]; then
		printf "missing dependency: wipe\n"
		exit 1
	fi
	if ! [[ -x "$(command -v tomb)" ]]; then
		printf "missing dependency: tomb\n"
		exit 1
	fi
	if ! [[ -x "$(command -v spectre)" ]]; then
		printf "missing dependency: spectre\n"
		exit 1
	fi
	if ! [[ -x "$(command -v pass)" ]]; then
		printf "missing dependency: pass\n"
		exit 1
	fi
	if ! [[ -x "$(command -v gpg2)" ]]; then
		printf "missing dependency: gpg2\n"
		exit 1
	fi
	if ! [[ -x "$(command -v xclip)" ]]; then
		printf "missing dependency: xclip\n"
		exit 1
	fi
	if ! [[ -x "$(command -v socat)" ]]; then
		printf "missing dependency: socat\n"
		exit 1
	fi
	if ! [[ -x "$(command -v pinentry-curses)" ]]; then
		printf "missing dependency: pinentry-curses\n"
		exit 1
	fi

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	hush )
		action="hush"
		shift
		risks_hush_parse_requirements "$@"
		shift $#
		;;

	backup )
		action="backup"
		shift
		risks_backup_parse_requirements "$@"
		shift $#
		;;

	new )
		action="new"
		shift
		risks_new_parse_requirements "$@"
		shift $#
		;;

	open )
		action="open"
		shift
		risks_open_parse_requirements "$@"
		shift $#
		;;

	close )
		action="close"
		shift
		risks_close_parse_requirements "$@"
		shift $#
		;;

	list )
		action="list"
		shift
		risks_list_parse_requirements "$@"
		shift $#
		;;

	slam )
		action="slam"
		shift
		risks_slam_parse_requirements "$@"
		shift $#
		;;

	gpgpass )
		action="gpgpass"
		shift
		risks_gpgpass_parse_requirements "$@"
		shift $#
		;;

	load )
		action="load"
		shift
		risks_load_parse_requirements "$@"
		shift $#
		;;

	save )
		action="save"
		shift
		risks_save_parse_requirements "$@"
		shift $#
		;;

	kv )
		action="kv"
		shift
		risks_kv_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risks_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	mount )
		action="mount"
		shift
		risks_hush_mount_parse_requirements "$@"
		shift $#
		;;

	rw )
		action="rw"
		shift
		risks_hush_rw_parse_requirements "$@"
		shift $#
		;;

	ro )
		action="ro"
		shift
		risks_hush_ro_parse_requirements "$@"
		shift $#
		;;

	umount )
		action="umount"
		shift
		risks_hush_umount_parse_requirements "$@"
		shift $#
		;;

	format )
		action="format"
		shift
		risks_hush_format_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risks_hush_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_mount_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_mount_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush mount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_rw_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_rw_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush rw"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_ro_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_ro_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush ro"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_umount_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_umount_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush umount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_hush_format_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_hush_format_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush format"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--size-percent | -P )
			# :flag.conflicts
			if [[ -n "${args[--size-absolute]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--size-absolute"
				exit 1
			fi

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--size-percent]="$2"
				shift
				shift
			else
				printf "%s\n" "--size-percent requires an argument: --size-percent, -P PERCENT"
				exit 1
			fi
			;;

		# :flag.case
		--size-absolute | -A )
			# :flag.conflicts
			if [[ -n "${args[--size-percent]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--size-percent"
				exit 1
			fi

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then
				# :flag.validations
				if [[ -n $(validate_partition_size "$2") ]]; then
					printf "validation error in %s:\n%s\n" "--size-absolute, -A SIZE" "$(validate_partition_size "$2")"
					exit 1
				fi

				args[--size-absolute]="$2"
				shift
				shift
			else
				printf "%s\n" "--size-absolute requires an argument: --size-absolute, -A SIZE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_file_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_file_exists "$1")"
					exit 1
				fi

				args[device]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[device]+x} ]]; then
		printf "missing required argument: DEVICE\nusage: risks hush format DEVICE [options]\n"
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args[--size-percent]:-} ]] || args[--size-percent]="90"

}

# :command.parse_requirements
risks_backup_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	mount )
		action="mount"
		shift
		risks_backup_mount_parse_requirements "$@"
		shift $#
		;;

	umount )
		action="umount"
		shift
		risks_backup_umount_parse_requirements "$@"
		shift $#
		;;

	format )
		action="format"
		shift
		risks_backup_format_parse_requirements "$@"
		shift $#
		;;

	identity )
		action="identity"
		shift
		risks_backup_identity_parse_requirements "$@"
		shift $#
		;;

	hush )
		action="hush"
		shift
		risks_backup_hush_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risks_backup_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_backup_mount_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_mount_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup mount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[backup_device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_file_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "BACKUP_DEVICE" "$(validate_file_exists "$1")"
					exit 1
				fi

				args[backup_device]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[backup_device]+x} ]]; then
		printf "missing required argument: BACKUP_DEVICE\nusage: risks backup mount BACKUP_DEVICE\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_backup_umount_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_umount_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup umount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_backup_format_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_format_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup format"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_file_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_file_exists "$1")"
					exit 1
				fi

				args[device]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[device]+x} ]]; then
		printf "missing required argument: DEVICE\nusage: risks backup format DEVICE [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_backup_identity_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_identity_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup identity"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--log-file | -f )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--log-file]="$2"
				shift
				shift
			else
				printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

}

# :command.parse_requirements
risks_backup_hush_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_backup_hush_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup hush"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_new_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_new_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	identity )
		action="identity"
		shift
		risks_new_identity_parse_requirements "$@"
		shift $#
		;;

	tomb )
		action="tomb"
		shift
		risks_new_tomb_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risks_new_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_new_identity_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_new_identity_usage
		exit
		;;

	esac

	# :command.command_filter
	action="new identity"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--log | -l )

			# :flag.case_no_arg
			args[--log]=1
			shift
			;;

		# :flag.case
		--log-file | -f )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--log-file]="$2"
				shift
				shift
			else
				printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[name]+x} ]]; then

				args[name]=$1
				shift
			elif [[ -z ${args[email]+x} ]]; then

				args[email]=$1
				shift
			elif [[ -z ${args[expiry_date]+x} ]]; then

				args[expiry_date]=$1
				shift
			elif [[ -z ${args[backup_device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_device "$1") ]]; then
					printf "validation error in %s:\n%s\n" "BACKUP_DEVICE" "$(validate_device "$1")"
					exit 1
				fi

				args[backup_device]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[name]+x} ]]; then
		printf "missing required argument: NAME\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
		exit 1
	fi
	if [[ -z ${args[email]+x} ]]; then
		printf "missing required argument: EMAIL\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
		exit 1
	fi
	if [[ -z ${args[expiry_date]+x} ]]; then
		printf "missing required argument: EXPIRY_DATE\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
		exit 1
	fi
	if [[ -z ${args[backup_device]+x} ]]; then
		printf "missing required argument: BACKUP_DEVICE\nusage: risks new identity NAME EMAIL EXPIRY_DATE BACKUP_DEVICE [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_new_tomb_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_new_tomb_usage
		exit
		;;

	esac

	# :command.command_filter
	action="new tomb"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--log | -l )

			# :flag.case_no_arg
			args[--log]=1
			shift
			;;

		# :flag.case
		--log-file | -f )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--log-file]="$2"
				shift
				shift
			else
				printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[tomb_name]+x} ]]; then

				args[tomb_name]=$1
				shift
			elif [[ -z ${args[size]+x} ]]; then

				args[size]=$1
				shift
			elif [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[tomb_name]+x} ]]; then
		printf "missing required argument: TOMB_NAME\nusage: risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
		exit 1
	fi
	if [[ -z ${args[size]+x} ]]; then
		printf "missing required argument: SIZE\nusage: risks new tomb TOMB_NAME SIZE [IDENTITY] [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_open_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_open_usage
		exit
		;;

	esac

	# :command.command_filter
	action="open"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--log | -l )

			# :flag.case_no_arg
			args[--log]=1
			shift
			;;

		# :flag.case
		--log-file | -f )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--log-file]="$2"
				shift
				shift
			else
				printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[resource]+x} ]]; then

				args[resource]=$1
				shift
			elif [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[resource]+x} ]]; then
		printf "missing required argument: RESOURCE\nusage: risks open RESOURCE [IDENTITY] [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_close_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_close_usage
		exit
		;;

	esac

	# :command.command_filter
	action="close"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--log | -l )

			# :flag.case_no_arg
			args[--log]=1
			shift
			;;

		# :flag.case
		--log-file | -f )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--log-file]="$2"
				shift
				shift
			else
				printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[resource]+x} ]]; then

				args[resource]=$1
				shift
			elif [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[resource]+x} ]]; then
		printf "missing required argument: RESOURCE\nusage: risks close RESOURCE [IDENTITY] [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_list_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_list_usage
		exit
		;;

	esac

	# :command.command_filter
	action="list"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[resource]+x} ]]; then

				args[resource]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

}

# :command.parse_requirements
risks_slam_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_slam_usage
		exit
		;;

	esac

	# :command.command_filter
	action="slam"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_gpgpass_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_gpgpass_usage
		exit
		;;

	esac

	# :command.command_filter
	action="gpgpass"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--timeout | -t )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--timeout]="$2"
				shift
				shift
			else
				printf "%s\n" "--timeout requires an argument: --timeout, -t TIMEOUT"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args[--timeout]:-} ]] || args[--timeout]="45"

}

# :command.parse_requirements
risks_load_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_load_usage
		exit
		;;

	esac

	# :command.command_filter
	action="load"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--close-tomb | -c )

			# :flag.case_no_arg
			args[--close-tomb]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[resource]+x} ]]; then

				args[resource]=$1
				shift
			elif [[ -z ${args[source_vm]+x} ]]; then

				args[source_vm]=$1
				shift
			elif [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[resource]+x} ]]; then
		printf "missing required argument: RESOURCE\nusage: risks load RESOURCE SOURCE_VM [IDENTITY] [options]\n"
		exit 1
	fi
	if [[ -z ${args[source_vm]+x} ]]; then
		printf "missing required argument: SOURCE_VM\nusage: risks load RESOURCE SOURCE_VM [IDENTITY] [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_save_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_save_usage
		exit
		;;

	esac

	# :command.command_filter
	action="save"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--close-tomb | -c )

			# :flag.case_no_arg
			args[--close-tomb]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[source_vm]+x} ]]; then

				args[source_vm]=$1
				shift
			elif [[ -z ${args[resource]+x} ]]; then

				args[resource]=$1
				shift
			elif [[ -z ${args[identity]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_identity_exists "$1") ]]; then
					printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")"
					exit 1
				fi

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[source_vm]+x} ]]; then
		printf "missing required argument: SOURCE_VM\nusage: risks save SOURCE_VM RESOURCE [IDENTITY] [options]\n"
		exit 1
	fi
	if [[ -z ${args[resource]+x} ]]; then
		printf "missing required argument: RESOURCE\nusage: risks save SOURCE_VM RESOURCE [IDENTITY] [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_kv_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	set )
		action="set"
		shift
		risks_kv_set_parse_requirements "$@"
		shift $#
		;;

	get )
		action="get"
		shift
		risks_kv_get_parse_requirements "$@"
		shift $#
		;;

	unset )
		action="unset"
		shift
		risks_kv_unset_parse_requirements "$@"
		shift $#
		;;

	list )
		action="list"
		shift
		risks_kv_list_parse_requirements "$@"
		shift $#
		;;

	clean )
		action="clean"
		shift
		risks_kv_clean_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risks_kv_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_kv_set_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_set_usage
		exit
		;;

	esac

	# :command.command_filter
	action="kv set"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[key]+x} ]]; then

				args[key]=$1
				shift
			elif [[ -z ${args[value]+x} ]]; then

				args[value]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[key]+x} ]]; then
		printf "missing required argument: KEY\nusage: risks kv set KEY VALUE\n"
		exit 1
	fi
	if [[ -z ${args[value]+x} ]]; then
		printf "missing required argument: VALUE\nusage: risks kv set KEY VALUE\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_kv_get_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_get_usage
		exit
		;;

	esac

	# :command.command_filter
	action="kv get"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[key]+x} ]]; then

				args[key]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[key]+x} ]]; then
		printf "missing required argument: KEY\nusage: risks kv get KEY\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_kv_unset_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_unset_usage
		exit
		;;

	esac

	# :command.command_filter
	action="kv unset"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[key]+x} ]]; then

				args[key]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[key]+x} ]]; then
		printf "missing required argument: KEY\nusage: risks kv unset KEY\n"
		exit 1
	fi

}

# :command.parse_requirements
risks_kv_list_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_list_usage
		exit
		;;

	esac

	# :command.command_filter
	action="kv list"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risks_kv_clean_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risks_kv_clean_usage
		exit
		;;

	esac

	# :command.command_filter
	action="kv clean"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.initialize
initialize() {
	version="0.1.0"
	long_usage=''
	

	# src/initialize.sh

	# Connected terminal
	typeset -H _TTY
	GPG_TTY=$(tty)  # Needed for GPG operations
	export GPG_TTY

	# Remove verbose errors when * don't yield any match in ZSH
	setopt +o nomatch

	# Default tombs and corresponding mount points (CONSTANTS) .........................................
	typeset -gr GPG_TOMB_LABEL="GPG"          # Stores an identity GPG private keys. Seldom opened
	typeset -gr SSH_TOMB_LABEL="ssh"          # Stores SSH keypairs
	typeset -gr MGMT_TOMB_LABEL="mgmt"        # Holds the key-value store, and anything the user wants.
	typeset -gr PASS_TOMB_LABEL="pass"        # Holds the password store data
	typeset -gr SIGNAL_TOMB_LABEL="signal"    # Holds data for Signal messenger (contacts, keys, configs, etc)

	# Other default security-related default directories/names .........................................
	typeset -gr RAMDISK="${HOME}/.gnupg"      # Actually not a tomb mount point: used by coffin

	typeset -gr RISKS_IDENTITY_FILE="${HOME}/.identity"      # Currently unlocked identity stored in file
	typeset -gr DEFAULT_KV_USER_DIR="$HOME/.tomb/mgmt/db/"   # Path to key=value store within mgmnt tomb

	typeset -gr RISKS_SCRIPTS_INSTALL_PATH="${HUSH_DIR}/.risks-scripts" # Path to risks bin in the hush
	typeset -gr BACKUP_MOUNT_DIR="/tmp/pendrive"

	typeset -gr FILE_ENCRYPTION="file_encryption_key" # Simply used as site name in spectre call.

	# Sensitive & and recurring variables used by program ..............................................
	typeset -gH IDENTITY
	typeset -gH FILE_ENCRYPTION_KEY
	typeset -gH GPG_PASS

	# Variables potentially overrode by user in their shell/rc .........................................
	typeset -gH GPGPASS_TIMEOUT=45            # Can be modified with --timeout flag on gpgpass command

	# Password-store
	export PASSWORD_STORE_ENABLE_EXTENSIONS=true
	export PASSWORD_STORE_GENERATED_LENGTH=20

	#----------------------------#

	# Don't run as root
	if [[ $EUID -eq 0 ]]; then
		 echo "This script must be run as user"
		 exit 2
	fi

	# Use colors unless told not to
	{ ! option_is_set --no-color } && { autoload -Uz colors && colors }
	# Some options are only available during insecure mode
	{ ! option_is_set --unsafe } && {
			for opt in --tomb-pwd --tomb-old-pwd; do
					{ option_is_set $opt } && {
							exitv=127 _failure "You specified option ::1 option::, \
							which is DANGEROUS and should only be used for testing\n \
							If you really want so, add --unsafe" $opt }
			done
	}

}

# :command.run
run() {
	declare -A args=()
	declare -a other_args=()
	declare -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	if [[ $action == "hush" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_usage
		else
			risks_hush_command
		fi

	elif [[ $action == "hush mount" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_mount_usage
		else
			risks_hush_mount_command
		fi

	elif [[ $action == "hush rw" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_rw_usage
		else
			risks_hush_rw_command
		fi

	elif [[ $action == "hush ro" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_ro_usage
		else
			risks_hush_ro_command
		fi

	elif [[ $action == "hush umount" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_umount_usage
		else
			risks_hush_umount_command
		fi

	elif [[ $action == "hush format" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_hush_format_usage
		else
			risks_hush_format_command
		fi

	elif [[ $action == "backup" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_usage
		else
			risks_backup_command
		fi

	elif [[ $action == "backup mount" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_mount_usage
		else
			risks_backup_mount_command
		fi

	elif [[ $action == "backup umount" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_umount_usage
		else
			risks_backup_umount_command
		fi

	elif [[ $action == "backup format" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_format_usage
		else
			risks_backup_format_command
		fi

	elif [[ $action == "backup identity" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_identity_usage
		else
			risks_backup_identity_command
		fi

	elif [[ $action == "backup hush" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_backup_hush_usage
		else
			risks_backup_hush_command
		fi

	elif [[ $action == "new" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_new_usage
		else
			risks_new_command
		fi

	elif [[ $action == "new identity" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_new_identity_usage
		else
			risks_new_identity_command
		fi

	elif [[ $action == "new tomb" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_new_tomb_usage
		else
			risks_new_tomb_command
		fi

	elif [[ $action == "open" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_open_usage
		else
			risks_open_command
		fi

	elif [[ $action == "close" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_close_usage
		else
			risks_close_command
		fi

	elif [[ $action == "list" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_list_usage
		else
			risks_list_command
		fi

	elif [[ $action == "slam" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_slam_usage
		else
			risks_slam_command
		fi

	elif [[ $action == "gpgpass" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_gpgpass_usage
		else
			risks_gpgpass_command
		fi

	elif [[ $action == "load" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_load_usage
		else
			risks_load_command
		fi

	elif [[ $action == "save" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_save_usage
		else
			risks_save_command
		fi

	elif [[ $action == "kv" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_usage
		else
			risks_kv_command
		fi

	elif [[ $action == "kv set" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_set_usage
		else
			risks_kv_set_command
		fi

	elif [[ $action == "kv get" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_get_usage
		else
			risks_kv_get_command
		fi

	elif [[ $action == "kv unset" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_unset_usage
		else
			risks_kv_unset_command
		fi

	elif [[ $action == "kv list" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_list_usage
		else
			risks_kv_list_command
		fi

	elif [[ $action == "kv clean" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risks_kv_clean_usage
		else
			risks_kv_clean_command
		fi

	elif [[ $action == "root" ]]; then
		root_command
	fi
}

initialize
run "$@"
