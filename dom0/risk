#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
risk_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk - RISKS Dom0 management application\n"
		echo

	else
		printf "risk - RISKS Dom0 management application\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk [command]\n"
	printf "  risk [command] --help | -h\n"
	printf "  risk --version | -v\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  hush       Manage the hush partition attach/detach from qubes"
	echo "  backup     Manage backup devices attach/detach from qubes"
	echo "  identity   Create, manage and use identities and/or use their machines"
	echo "  vpn        Create, configure, manage and use VPN gateways for an identity."
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo
		echo "  --version, -v"
		printf "    Show version number\n"
		echo

		# :command.usage_environment_variables
		printf "Environment Variables:\n"

		# :environment_variable.usage
		echo "  SDCARD_BLOCK"
		printf "    Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc\n"
		echo

		# :environment_variable.usage
		echo "  BACKUP_BLOCK"
		printf "    Qubes path to backup device, such as 'sys-usb:sdb1'\n"
		echo

		# :environment_variable.usage
		echo "  RISK_VPN_TEMPLATE"
		printf "    Default TemplateVM to use for VPN VMs\n"
		printf "    Default: sys-vpn\n"
		echo

		# :environment_variable.usage
		echo "  RISK_SPLIT_BROWSER_TEMPLATE"
		printf "    Default template to use for split-browser backend\n"
		echo

		# :environment_variable.usage
		echo "  RISK_WHONIX_WS"
		printf "    Default Whonix Workstation AppVM to use for identity client machine\n"
		echo

		# :environment_variable.usage
		echo "  RISK_VPN_VM"
		printf "    Default AppVM to use for cloning new VPN qubes\n"
		echo

		# :environment_variable.usage
		echo "  RISK_SPLIT_BROWSER"
		printf "    Default AppVM to clone for split-browser backend\n"
		echo

		# :environment_variable.usage
		echo "  RISK_DEFAULT_NETVM"
		printf "    Default VM to use as a firewall VM, to which either Tor or VPN gateways are\n    bound\n"
		printf "    Default: sys-firewall\n"
		echo

		# :environment_variable.usage
		echo "  VAULT_VM"
		printf "    Default vault VM\n"
		printf "    Default: vault\n"
		echo

	fi
}

# :command.usage
risk_hush_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk hush - Manage the hush partition attach/detach from qubes\n"
		echo

	else
		printf "risk hush - Manage the hush partition attach/detach from qubes\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk hush [command]\n"
	printf "  risk hush [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  attach   Attach the hush device to a qube. Accepts optional args to override default hush/vault"
	echo "  detach   Detach the hush device from its current qube, making sure it's not in a read-write state"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_hush_attach_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
		echo

	else
		printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk hush attach [DEVICE] [VAULT_VM] [options]\n"
	printf "  risk hush attach --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  DEVICE"
		printf "    (optional) qubes path to device to use as hush (defaults to SDCARD_BLOCK)\n"
		echo

		# :argument.usage
		echo "  VAULT_VM"
		printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
		echo

	fi
}

# :command.usage
risk_hush_detach_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
		echo

	else
		printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk hush detach\n"
	printf "  risk hush detach --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_backup_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk backup - Manage backup devices attach/detach from qubes\n"
		echo

	else
		printf "risk backup - Manage backup devices attach/detach from qubes\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk backup [command]\n"
	printf "  risk backup [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  attach   Attach a backup device to a qube. Accepts optional args to override default backup/vault"
	echo "  detach   Detach the backup device from its current qube, making sure it's not in a read-write state"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_backup_attach_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
		echo

	else
		printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk backup attach [DEVICE] [VAULT_VM] [options]\n"
	printf "  risk backup attach --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  DEVICE"
		printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
		echo

		# :argument.usage
		echo "  VAULT_VM"
		printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
		echo

	fi
}

# :command.usage
risk_backup_detach_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
		echo

	else
		printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk backup detach\n"
	printf "  risk backup detach --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_identity_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity - Create, manage and use identities and/or use their machines\n"
		echo

	else
		printf "risk identity - Create, manage and use identities and/or use their machines\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity [command]\n"
	printf "  risk identity [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  create   Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)"
	echo "  delete   Destroys an identity and all its associated machines and data"
	echo "  open     Simply open the identity store in the vault"
	echo "  close    Simply close the identity store in the vault"
	echo "  start    Start the identity in the vault and all of its enabled VMs"
	echo "  stop     Stops all machines belonging to an identity, and close its vault if active."
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_identity_create_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
		echo

	else
		printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity create IDENTITY [options]\n"
	printf "  risk identity create --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --name, -N NAME"
		printf "    Use a different name for naming identity VMs\n"
		echo

		# :flag.usage
		echo "  --label, -L COLOR"
		printf "    Specify a label color to be used for all VMs belonging to this identity\n"
		echo

		# :flag.usage
		echo "  --no-gw, -G"
		printf "    Don't create a Whonix TOR gateway\n"
		echo

		# :flag.usage
		echo "  --clone-gw-from TOR_GW"
		printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
		echo

		# :flag.usage
		echo "  --no-vpn, -V"
		printf "    Don't create a VPN gateway\n"
		echo

		# :flag.usage
		echo "  --clone-vpn-from VPN_GW"
		printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
		echo

		# :flag.usage
		echo "  --vpn-over-tor"
		printf "    Instead of routing TOR traffic through the VPN, route the VPN traffic\n    through TOR\n"
		echo

		# :flag.usage
		echo "  --no-messenger, -M"
		printf "    Don't create a Messenger VM (for Signal and other message services)\n"
		echo

		# :flag.usage
		echo "  --clone-messenger-from MESSENGER_VM"
		printf "    Instead of creating the Messenger VM from a template, clone an existing\n    Messenger AppVM\n"
		echo

		# :flag.usage
		echo "  --clone-web-from WEB_VM"
		printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
		echo

		# :flag.usage
		echo "  --clone-split-from SPLIT_BROWSER_VM"
		printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Name of the identity for which to initialize infrastructure\n"
		echo

	fi
}

# :command.usage
risk_identity_delete_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
		echo

	else
		printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity delete IDENTITY [options]\n"
	printf "  risk identity delete --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity to delete along with machines\n"
		echo

	fi
}

# :command.usage
risk_identity_open_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity open - Simply open the identity store in the vault\n"
		echo

	else
		printf "risk identity open - Simply open the identity store in the vault\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity open IDENTITY [options]\n"
	printf "  risk identity open --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity to open in the vault\n"
		echo

	fi
}

# :command.usage
risk_identity_close_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity close - Simply close the identity store in the vault\n"
		echo

	else
		printf "risk identity close - Simply close the identity store in the vault\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity close [options]\n"
	printf "  risk identity close --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

	fi
}

# :command.usage
risk_identity_start_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
		echo

	else
		printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity start IDENTITY [options]\n"
	printf "  risk identity start --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  IDENTITY"
		printf "    Identity to start\n"
		echo

	fi
}

# :command.usage
risk_identity_stop_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
		echo

	else
		printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk identity stop [options]\n"
	printf "  risk identity stop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

	fi
}

# :command.usage
risk_vpn_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
		echo

	else
		printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn [command]\n"
	printf "  risk vpn [command] --help | -h\n"
	echo
	# :command.usage_commands
	printf "Commands:\n"
	echo "  create   Create VPN gateway from a template, or by cloning an existing one."
	echo "  setup    Manage, import network configurations and run associated setup wizards"
	echo "  start    Start a VPN gateway in the background"
	echo "  stop     Stop a VPN gateway"
	echo "  enable   Automatically start a VPN gateway when starting the identity."
	echo "  delete   Delete a VPN gateway"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
risk_vpn_create_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
		echo

	else
		printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn create [options]\n"
	printf "  risk vpn create --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --name, -N NAME"
		printf "    Use a different name for naming identity VMs\n"
		echo

		# :flag.usage
		echo "  --label, -L COLOR"
		printf "    Specify a label color to be used for all VMs belonging to this identity\n"
		echo

		# :flag.usage
		echo "  --no-vpn, -V"
		printf "    Don't create a VPN gateway\n"
		echo

		# :flag.usage
		echo "  --clone-vpn-from VPN_GW"
		printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
		echo

		# :flag.usage
		echo "  --vpn-over-tor"
		printf "    Instead of routing TOR traffic through the VPN, route the VPN traffic\n    through TOR\n"
		echo

	fi
}

# :command.usage
risk_vpn_setup_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
		echo

	else
		printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn setup VM [options]\n"
	printf "  risk vpn setup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :flag.usage
		echo "  --config-in, -c CONFIG_VM"
		printf "    VM in which to browse for VPN configuration(s)\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  VM"
		printf "    gateway VM to operate setup on\n"
		echo

	fi
}

# :command.usage
risk_vpn_start_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn start - Start a VPN gateway in the background\n"
		echo

	else
		printf "risk vpn start - Start a VPN gateway in the background\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn start VM [options]\n"
	printf "  risk vpn start --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  VM"
		printf "    gateway VM to start\n"
		echo

	fi
}

# :command.usage
risk_vpn_stop_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn stop - Stop a VPN gateway\n"
		echo

	else
		printf "risk vpn stop - Stop a VPN gateway\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn stop VM [options]\n"
	printf "  risk vpn stop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  VM"
		printf "    gateway VM to stop\n"
		echo

	fi
}

# :command.usage
risk_vpn_enable_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
		echo

	else
		printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn enable VM [options]\n"
	printf "  risk vpn enable --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  VM"
		printf "    gateway VM to enable autostart for\n"
		echo

	fi
}

# :command.usage
risk_vpn_delete_usage() {
	if [[ -n $long_usage ]]; then
		printf "risk vpn delete - Delete a VPN gateway\n"
		echo

	else
		printf "risk vpn delete - Delete a VPN gateway\n"
		echo

	fi

	printf "Usage:\n"
	printf "  risk vpn delete VM [options]\n"
	printf "  risk vpn delete --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "Options:\n"

		# :command.usage_fixed_flags
		echo "  --help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_flags
		# :flag.usage
		echo "  --verbose, -v"
		printf "    Show verbose logging\n"
		echo

		# :command.usage_args
		printf "Arguments:\n"

		# :argument.usage
		echo "  VM"
		printf "    gateway VM to delete\n"
		echo

	fi
}

# :command.normalize_input
normalize_input() {
	local arg flags

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for (( i=0 ; i < ${#flags} ; i++ )); do
				input+=("-${flags:i:1}")
			done
		else
			input+=("$arg")
		fi

		shift
	done
}
# :command.inspect_args
inspect_args() {
	readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
	if (( ${#args[@]} )); then
		echo args:
		for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
	else
		echo args: none
	fi

	if (( ${#other_args[@]} )); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi
}

# :command.user_lib
# src/lib/device.sh

# Checks that a given device is attached to a given VM
check_is_device_attached ()
{
		local block="$1"
		local vm="$2"

		local ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
		if [[ ${#ovm} -eq 0 ]] || [[ ${ovm} != "$vm" ]]; then
				_failure "Device block $block is not mounted on vault ${vm}"
		fi
}

# src/lib/identity.sh

# check that no identity is active in the vault, and fail if there is.
check_no_active_identity ()
{
		active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
		if [[ -n $active_identity ]]; then
				# It might be the same
				if [[ $active_identity == $1 ]]; then
						_message "Identity $1 is already active"
						exit 0
				fi

				_failure "Identity $active_identity is active. Close/slam/fold it and rerun this command"
		fi
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risk'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Simple way of setting the section and to update the padding
_in_section ()
{
		section="$1"
		if [[ -n "${2}" ]]; then
				section_padding="$2"
		fi
}


function is_verbose_set () {
		if [[ "${args[--verbose]}" -eq 1 ]]; then
				return 0
		else
				return 1
		fi
}

# Messaging function with pretty coloring
function _msg()

{
		# Check if we have been provided a section name,

		# and if not, that the section is set to a default.
		if [[ ${#@} -lt 3 ]]; then
				local progname="$section"
				if [[ -z "$progname" ]]; then
						progname='risks'
				fi
				local msg="$2"
		else
				local progname="$2"
				local msg="$3"
		fi

		# Padd the program/section name
		progname="$(printf %"${section_padding}"s "${progname}")"

		# Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

	local command="print -P"
	local pchars=""
	local pcolor="normal"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"; pchars=" > "; pcolor="yellow"
			;;
		message)
			pchars=" . "; pcolor="white"
			;;
		verbose)
			pchars="[D]"; pcolor="blue"
			;;
		success)
			pchars="(*)"; pcolor="green"
			;;
		warning)
			pchars="[W]"; pcolor="yellow"
			;;
		failure)
			pchars="[E]"; pcolor="red"
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		*)
			pchars="[F]"; pcolor="red"
			msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
			returncode=127
			;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

		# If there is a log-file specified with flag --log-file,
		# output the message to it, instead of the current file descriptor
		logfile="${args[--log-file]}"
		if [[ -n "${logfile}" ]]; then
				${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
				return $returncode
		fi

		# Else, print to stdout, with colors
	if [[ -t $fd ]]; then
			 [[ -n "$progname" ]] && progname="$fg[magenta]$progname$reset_color"
			 [[ -n "$pchars" ]] && pchars="$fg_bold[$pcolor]$pchars$reset_color"
			 msg="$fg[$pcolor]$msg$reset_color"
	fi

		${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _message() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
		option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose() {
		is_verbose_set && _msg verbose "$@"
	return 0
}

function _success() {
		option_is_set -q || _msg success "$@"
	return 0
}

function _warning() {
		option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()

{
	typeset -i exitcode=${exitv:-1}

		_msg failure "$@"
		if [[ -n "$COMMAND_STDERR" ]]; then
				_msg inline "$COMMAND_STDERR"
		fi

	# Be sure we forget the secrets we were told
		exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print() {
		option_is_set -q || _msg print "$@"
	return 0
}

# src/lib/messenger.sh

# Creates a new Messaging AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this VM

# $3 - Label
create_messenger_vm ()
{
		local msg="${1}-msg"
		local netvm="${2-$RISK_DEFAULT_NETVM}"
		local gw_label="${3-orange}"

		local -a create_command
		create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$WHONIX_WS_TEMPLATE")

		_message "Creating messaging VM (name: $msg / netvm: $netvm / template: $WHONIX_WS_TEMPLATE)"
}

# very similar to create_messenger_vm , except that we clone

# an existing AppVM instead of creating a new one from a Template.
clone_messenger_vm ()
{
		local msg="${1}-msg"
		local gw_clone="$2"
		local netvm="${3-$RISK_DEFAULT_NETVM}"
		local gw_label="${4-orange}"

		create_command+=(qvm-clone "${gw_clone}" "${msg}")

		local label_command=(qvm-prefs "$msg" label "$gw_label")
		local netvm_command=(qvm-prefs "$msg" netvm "$netvm")

		_message "Cloning messaging VM (name: $msg / netvm: $netvm / template: $gw_clone)"
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
		# The STDOUT/STDERR variables are populated, which
		# makes their content available to any subsequent call
		# to _failure, which needs STDERR output
		{
				IFS=$'\n' read -r -d '' COMMAND_STDERR;
				IFS=$'\n' read -r -d '' COMMAND_STDOUT;
				(IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
		} < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

		local ret="$?"

		# Output the command's result depending on the verbose mode
		# and if the command ran successfully. We check that either
		# stdout or stderr are non-empty: sometimes commands might
		# output to stderr, like wipe.
		if [[ $ret -eq 0 ]] && is_verbose_set ; then
				if [[ -n "$COMMAND_STDOUT" ]]; then
						_verbose "$COMMAND_STDOUT"
				fi
		fi

		# Return the command's exit code
		return $ret
}

# run a command in a qube
# $1 - Qube name
# $@ - Command string to run
_qrun () {
		local vm="$1"
		shift
		local command="$*"

		# Prepare the full command
		local xterm_command='zsh -c "'"$command"'"'
		local full_command=(qvm-run --pass-io "$vm" xterm -e "$xterm_command")

		_verbose "Running command: ${full_command[*]}"

		# Split io like in _run, and store the return value
		# Note that we don't double quote the $full_command variable.
		{
				IFS=$'\n' read -r -d '' COMMAND_STDERR;
				IFS=$'\n' read -r -d '' COMMAND_STDOUT;
				(IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
		} < <((printf '\0%s\0%d\0' "$(${full_command[@]})" "${?}" 1>&2) 2>&1)

		local ret="$?"

		# Output the command's result depending on the verbose mode
		# and if the command ran successfully like in _run also.
		if [[ $ret -eq 0 ]] && is_verbose_set ; then
				if [[ -n "$COMMAND_STDOUT" ]]; then
						_verbose "$COMMAND_STDOUT"
				fi
		fi

		return $ret
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
		local ret="$?"

		if [[ ! $ret -eq 0 ]]; then
				_failure "$@"
		fi
}

# src/lib/tor_gateway.sh

# Creates a new TOR Whonix gateway AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this gateway
# $3 - Label
create_tor_gateway ()
{
		local gw="${1}-gw"
		local netvm="${2-$RISK_DEFAULT_NETVM}"
		local gw_label="${3-yellow}"

		local -a create_command
		create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$WHONIX_GW_TEMPLATE")

		_message "Creating TOR gateway VM (name: $gw / netvm: $netvm / template: $WHONIX_GW_TEMPLATE)"
}

# very similar to create_tor_gateway, except that we clone an existing
# gateway AppVM instead of creating a new one from a Template.
clone_tor_gateway ()
{
		local gw="${1}-gw"
		local gw_clone="$2"
		local netvm="${3-$RISK_DEFAULT_NETVM}"
		local gw_label="${4-yellow}"

		create_command+=(qvm-clone "${gw_clone}" "${gw}")

		local label_command=(qvm-prefs "$gw" label "$gw_label")
		local netvm_command=(qvm-prefs "$gw" netvm "$netvm")

		_message "Cloning TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_clone)"
}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# src/lib/validations/validate_devices.sh

validate_device () {
		local block="$1"

		# And check not already attached to another qube
		ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
		if [[ ${#ovm} -gt 0 ]]; then

				# if [ "${ovm}" == "${vm}" ]; then
				#     echo "Block ${SDCARD_BLOCK} is already attached to ${vm}"
				#     exit 0
				# fi

				echo -e "Block ${SDCARD_BLOCK} is currently attached to ${ovm}."
				echo "Please umount it properly from there and rerun this program."
				return

				# slam tombs open in the vm
				#qvm-run -u user ${ovm} '/usr/local/bin/tomb slam all'

				# umount sdcard from the vm
				#qvm-run -u user ${ovm} '/usr/local/bin/risks umount sdcard'

				# detach the sdcard
				#qvm-block detach ${ovm} ${block}
						#if [ $? != 0 ]; then
				#	echo "Block ${block} can not be detached from ${ovm}. Aborted."
				#	exit
				#fi

		fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
	[[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
	[[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
	[[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
	[[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_vm.sh

# does the vm exist?
validate_vm_exits () {
		vm=""
		for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
		do
				if [ "${item}" == "${1}" ]; then
						vm=${1}
				fi
		done
		if [ ${#vm} -eq 0 ]; then
				echo "No vm with name ${1} exists or can not be used. Aborted."
				return
		fi
}

# Checks that the vault VM obeys a few requirements, like no network
validate_valid_vaultvm () {
		vm=""
		for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
		do
				if [ "${item}" == "${1}" ]; then
						vm=${1}
				fi
		done
		if [ ${#vm} -eq 0 ]; then
				echo "No vm with name ${1} exists or can not be used. Aborted."
				return
		fi

		netvm=$(qvm-prefs "${vm}" | grep "netvm" | awk '{print $3}')
		if [ "${netvm}" != "None" ]; then
				echo "${vm} might be connected to the internet. Aborted."
				echo "Check: qvm-prefs ${vm} | grep netvm"
		fi
}

# src/lib/vpn_gateway.sh
#!/usr/bin/env bash

# Creates a new VPN gateway from a TemplateVM
create_vpn_gateway ()
{
		local gw="${1}-gw"
		local netvm="${2-$RISK_DEFAULT_NETVM}"
		local gw_label="${3-blue}"

		local -a create_command
		create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$RISK_VPN_TEMPLATE")

		_message "Creating VPN gateway VM (name: $gw / netvm: $netvm / template: $RISK_VPN_TEMPLATE)"
}

# Creates a new VPN gateway from an existing VPN AppVM

clone_vpn_gateway ()
{
		local gw="${1}-vpn"
		local gw_clone="$2"
		local netvm="${3-$RISK_DEFAULT_NETVM}"
		local gw_label="${4-blue}"

		# Create the VPN
		local -a create_command
		create_command+=(qvm-clone "${gw_clone}" "${gw}")

		local label_command=(qvm-prefs "$gw" label "$gw_label")
		local netvm_command=(qvm-prefs "$gw" netvm "$netvm")

		_message "Cloning VPN gateway VM (name: $gw / netvm: $netvm / template: $gw_clone)"

		# For now disposable are not allowed, since it would create too many VMs,

		# and complicate a bit the setup steps for VPNs. If the clone is a template
		# for disposables, unset it
		local disp_template
		# disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
		# [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False
}

# src/lib/web.sh

# Create a web browsing VM from a template
create_browser_vm ()
{
		local web="${1}-web"
		local netvm="${2-$RISK_DEFAULT_NETVM}"
		local web_label="${3-orange}"

		local -a create_command
		create_command+=(qvm-create --property netvm="$netvm" --label "$web_label" --template "$WHONIX_WS_TEMPLATE")

		_message "Creating web VM (name: $web / netvm: $netvm / template: $WHONIX_WS_TEMPLATE)"
}

# Clone a web browsing VM from an existing one
clone_browser_vm ()
{
		local web="${1}-web"
		local web_clone="$2"
		local netvm="${3-$RISK_DEFAULT_NETVM}"
		local web_label="${4-orange}"

		create_command+=(qvm-clone "${web_clone}" "${web}")

		local label_command=(qvm-prefs "$web" label "$web_label")
		local netvm_command=(qvm-prefs "$web" netvm "$netvm")

		_message "Cloning web VM (name: $web / netvm: $netvm / template: $web_clone)"
}

# Create a split-browser VM from a template
create_split_browser_vm ()
{
		local web="${1}-split-web"
		local web_label="${2-gray}"

		local -a create_command
		create_command+=(qvm-create --property netvm=None --label "$web_label" --template "$RISK_SPLIT_BROWSER_TEMPLATE")

		_message "Creating split-browser (name: $web / netvm: $netvm / template: $RISK_SPLIT_BROWSER_TEMPLATE)"
}

# Clone an existing split-browser VM, and change its dispvms
clone_split_browser_vm ()
{
		local web="${1}-split-web"
		local web_clone="$2"
		local web_label="${3-gray}"

		create_command+=(qvm-clone "${web_clone}" "${web}")

		local label_command=(qvm-prefs "$web" label "$web_label")
		local netvm_command=(qvm-prefs "$web" netvm None)

		_message "Cloning split-browser VM (name: $web / netvm: $netvm / template: $web_clone)"
}

# :command.command_functions

# :command.function
risk_hush_attach_command() {
	# src/hush_attach_command.sh

	local block vm

	block="${args[device]-$SDCARD_BLOCK}"
	vm="${args[vault_vm]-$VAULT_VM}"

	# If the validations were not performed because

	# we use a default environment variable for the
	# vault VM, perform them again here.
	local error_invalid_vm=$(validate_valid_vaultvm "$vm")
	if [[ -n "$error_invalid_vm" ]]; then
			_failure "$error_invalid_vm"
	fi

	# Do the same for the hush device
	local error_device=$(validate_device "$block")
	if [[ -n "$error_device" ]]; then
			_failure "$error_device"
	fi

	# is the vm running?
	qvm-ls | grep Running | awk {'print $1'} | grep "^"${vm}"$" &> /dev/null
	if [ "$?" != "0" ]; then
			_verbose "Starting VM $vm"
			qvm-start "${vm}"
		sleep 15
	fi

	# finally attach the sdcard encrypted partition to the qube
	qvm-block attach "${vm}" "${block}"
	if [[ $? -eq 0 ]]; then
		_success "Block ${block} has been attached to ${vm}"
	else
		_success "Block ${block} can not be attached to ${vm}"
	fi

}

# :command.function
risk_hush_detach_command() {
	# src/hush_detach_command.sh
	echo "# this file is located in 'src/hush_detach_command.sh'"
	echo "# code for 'risk hush detach' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_backup_attach_command() {
	# src/backup_attach_command.sh

	local block vm

	block="${args[device]-$BACKUP_BLOCK}"
	vm="${args[vault_vm]-$VAULT_VM}"

	# If the validations were not performed because

	# we use a default environment variable for the
	# vault VM, perform them again here.
	local error_invalid_vm=$(validate_vm_exits "$vm")
	if [[ -n "$error_invalid_vm" ]]; then
			_failure "$error_invalid_vm"
	fi

	# Do the same for the hush device
	local error_device=$(validate_device "$block")
	if [[ -n "$error_device" ]]; then
			_failure "$error_device"
	fi

	# is the vm running?
	qvm-ls | grep Running | awk {'print $1'} | grep "^"${vm}"$" &> /dev/null
	if [ "$?" != "0" ]; then
			_verbose "Starting VM $vm"
			qvm-start "${vm}"
		sleep 15
	fi

	# finally attach the sdcard encrypted partition to the qube
	qvm-block attach "${vm}" "${block}"
	if [[ $? -eq 0 ]]; then
		_success "Block ${block} has been attached to ${vm}"
	else
		_success "Block ${block} can not be attached to ${vm}"
	fi

}

# :command.function
risk_backup_detach_command() {
	# src/backup_detach_command.sh
	local block="${BACKUP_BLOCK}"
	local vm="${VAULT_VM}"

	qvm-block detach "${vm}" "${block}"
	if [[ $? -eq 0 ]]; then
		_success "Block ${SDCARD_BLOCK} has been detached from to ${vm}"
	else
		_success "Block ${SDCARD_BLOCK} can not be detached from ${vm}"
	fi

}

# :command.function
risk_identity_create_command() {
	# src/identity_create_command.sh

	local identity="${args[identity]}"

	# Identity checks and basic setup ==========================================

	# First open the identity, because we might need its credentials and stuff
	# The identity argument is here, so this command has the arguments it needs
	active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
	if [[ -n $active_identity ]]; then
			# It might be the same
			if [[ $active_identity != "$identity" ]]; then
					_failure "Another identity ($identity) is active. Close/slam/fold it and rerun this command"
			fi
	else
			risk_open_identity_command
			_catch "Failed to open identity $identity"
	fi

	# Make a directory for this identity, and store the associated VM name
	local identity_dir="${RISK_IDENTITIES_DIR}/$identity"
	[[ -e ${identity_dir} ]] || mkdir -p "$identity_dir"

	# Else we're good to go
	_message "Initializing infrastructure for identity $identity"

	# Default settings and values ==============================================

	# If the user wants to use a different name for the VMs
	local name="${args[--name]-$identity}"
	echo "$name" > "${identity_dir}/vm_name"

	_message "Using name '$name' as VM base name"

	local label="${args[--label]}"

	# Prepare the root NetVM for this identity

	# Network VMs ==============================================================
	_message "Creating network VMs:"

	# 1 - Tor gateway, if not explicitly disabled
	if [[ ${args[--no-gw]} -eq 0 ]]; then
			local gw_netvm

			# We either clone the gateway from an existing one,
			# or we create it from a template.
			if [[ -n ${args[--clone-gw-from]} ]]; then
					local clone="${args[--clone-gw-from]}"
					clone_tor_gateway "$name" "$clone" "$gw_netvm" "$label"
			else
					create_tor_gateway "$name" "$gw_netvm" "$label"
			fi
	else
			_message "Skipping TOR gateway"
	fi

	# 2 - VPNs, if not explicitly disabled
	if [[ ${args[--no-vpn]} -eq 0 ]]; then
			local vpn_netvm

			# We either clone the gateway from an existing one,
			# or we create it from a template.
			if [[ -n ${args[--clone-vpn-from]} ]]; then
					local clone="${args[--clone-vpn-from]}"
					clone_vpn_gateway "$name" "$clone" "$vpn_netvm" "$label"
			else
					create_vpn_gateway "$name" "$vpn_netvm" "$label"
			fi
	else
			_message "Skipping VPN gateway"
	fi

	# 3 - Setting up the network routes
	if [[ ${args[--vpn-over-tor]} -eq 1 ]]; then
			echo
	fi

	# At this point we should know the name of the VM to be used as NetVM
	# for the subsquent machines, such as web browsing and messaging VMs.

	# Message VMs ==============================================================
	_message "Creating messaging VMs:"

	if [[ ${args[--no-messenger]} -eq 0 ]]; then
			local msg="${name}-msg"
	else
			_message "Skipping messaging VM"
	fi

	# Browser VMs ==============================================================
	_message "Creating web VMs:"

	# Browser VMs are disposable, but we make a template for this identity,
	# since we might  either modify stuff in there, and we need them at least

	# to have a different network route.
	if [[ -n ${args[--clone-web-from]} ]]; then
			local web_netvm

			local clone="${args[--clone-web-from]}"
			clone_browser_vm "$name" "$clone" "$web_netvm" "$label"
	else
			create_browser_vm "$name" "$web_netvm" "$label"
	fi

	# Split-browser has its own dispVMs and bookmarks
	local split_web="${name}-split-web"
	if [[ -n ${args[--clone-split-from]} ]]; then
			local clone="${args[--clone-split-from]}"
			clone_split_browser_vm "$name" "$clone" "$label"
	else
			create_split_browser_vm "$name" "$label"
	fi

	_success "Successfully initialized infrastructure for identity $identity"

}

# :command.function
risk_identity_delete_command() {
	# src/identity_delete_command.sh
	echo "# this file is located in 'src/identity_delete_command.sh'"
	echo "# code for 'risk identity delete' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_identity_open_command() {
	# src/identity_open_command.sh

	local identity="${args[identity]}"

	# 1 - Check that hush is mounted on vault
	# TODO: change this, since it only checks for the default vault VM
	check_is_device_attached "${SDCARD_BLOCK}" "${VAULT_VM}"

	# 2 - Check that no identity is currently opened
	# The second line should be empty, as opposed to being an encrypted coffin name
	check_no_active_identity "$identity"

	# 3 - Send commands to vault
	_message "Opening identity $identity"

	_qrun "$VAULT_VM" risks open identity "$identity"
	_catch "Failed to open identity"

	_message "Identity $identity is active"

}

# :command.function
risk_identity_close_command() {
	# src/identity_close_command.sh

	# Check we have an active identity
	active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
	if [[ -z $active_identity ]]; then
			_message "No active identity to close"
			exit 0
	fi

	_message "Closing identity $active_identity"

	_qrun "$VAULT_VM" risks close identity "$active_identity"
	_catch "Failed to close identity $active_identity"

	_message "Identity $active_identity is closed"

}

# :command.function
risk_identity_start_command() {
	# src/identity_start_command.sh

	local identity="${args[identity]}"

	# Get the name for VMs
	local identity_dir="${RISK_IDENTITIES_DIR}/$identity"
	local name="$(cat "${identity_dir}/vm_name")"

}

# :command.function
risk_identity_stop_command() {
	# src/identity_stop_command.sh
	echo "# this file is located in 'src/identity_stop_command.sh'"
	echo "# code for 'risk identity stop' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_create_command() {
	# src/vpn_create_command.sh
	echo "# this file is located in 'src/vpn_create_command.sh'"
	echo "# code for 'risk vpn create' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_setup_command() {
	# src/vpn_setup_command.sh
	echo "# this file is located in 'src/vpn_setup_command.sh'"
	echo "# code for 'risk vpn setup' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_start_command() {
	# src/vpn_start_command.sh
	echo "# this file is located in 'src/vpn_start_command.sh'"
	echo "# code for 'risk vpn start' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_stop_command() {
	# src/vpn_stop_command.sh
	echo "# this file is located in 'src/vpn_stop_command.sh'"
	echo "# code for 'risk vpn stop' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_enable_command() {
	# src/vpn_enable_command.sh
	echo "# this file is located in 'src/vpn_enable_command.sh'"
	echo "# code for 'risk vpn enable' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.function
risk_vpn_delete_command() {
	# src/vpn_delete_command.sh
	echo "# this file is located in 'src/vpn_delete_command.sh'"
	echo "# code for 'risk vpn delete' goes here"
	echo "# you can edit it freely and regenerate (it will not be overwritten)"
	inspect_args

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--version | -v )
		version_command
		exit
		;;

	--help | -h )
		long_usage=yes
		risk_usage
		exit
		;;

	esac

	# :command.environment_variables_filter
	export RISK_VPN_TEMPLATE="${RISK_VPN_TEMPLATE:-sys-vpn}"
	export RISK_DEFAULT_NETVM="${RISK_DEFAULT_NETVM:-sys-firewall}"
	export VAULT_VM="${VAULT_VM:-vault}"

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	hush )
		action="hush"
		shift
		risk_hush_parse_requirements "$@"
		shift $#
		;;

	backup )
		action="backup"
		shift
		risk_backup_parse_requirements "$@"
		shift $#
		;;

	identity )
		action="identity"
		shift
		risk_identity_parse_requirements "$@"
		shift $#
		;;

	vpn )
		action="vpn"
		shift
		risk_vpn_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risk_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_hush_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_hush_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	attach )
		action="attach"
		shift
		risk_hush_attach_parse_requirements "$@"
		shift $#
		;;

	detach )
		action="detach"
		shift
		risk_hush_detach_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risk_hush_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_hush_attach_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_hush_attach_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush attach"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_device "$1") ]]; then
					printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")"
					exit 1
				fi

				args[device]=$1
				shift
			elif [[ -z ${args[vault_vm]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_valid_vaultvm "$1") ]]; then
					printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")"
					exit 1
				fi

				args[vault_vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

}

# :command.parse_requirements
risk_hush_detach_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_hush_detach_usage
		exit
		;;

	esac

	# :command.command_filter
	action="hush detach"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_backup_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_backup_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	attach )
		action="attach"
		shift
		risk_backup_attach_parse_requirements "$@"
		shift $#
		;;

	detach )
		action="detach"
		shift
		risk_backup_detach_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risk_backup_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_backup_attach_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_backup_attach_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup attach"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[device]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_device "$1") ]]; then
					printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")"
					exit 1
				fi

				args[device]=$1
				shift
			elif [[ -z ${args[vault_vm]+x} ]]; then
				# :argument.validations
				if [[ -n $(validate_valid_vaultvm "$1") ]]; then
					printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")"
					exit 1
				fi

				args[vault_vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

}

# :command.parse_requirements
risk_backup_detach_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_backup_detach_usage
		exit
		;;

	esac

	# :command.command_filter
	action="backup detach"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_identity_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	create )
		action="create"
		shift
		risk_identity_create_parse_requirements "$@"
		shift $#
		;;

	delete )
		action="delete"
		shift
		risk_identity_delete_parse_requirements "$@"
		shift $#
		;;

	open )
		action="open"
		shift
		risk_identity_open_parse_requirements "$@"
		shift $#
		;;

	close )
		action="close"
		shift
		risk_identity_close_parse_requirements "$@"
		shift $#
		;;

	start )
		action="start"
		shift
		risk_identity_start_parse_requirements "$@"
		shift $#
		;;

	stop )
		action="stop"
		shift
		risk_identity_stop_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risk_identity_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_identity_create_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_create_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity create"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--name | -N )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--name]="$2"
				shift
				shift
			else
				printf "%s\n" "--name requires an argument: --name, -N NAME"
				exit 1
			fi
			;;

		# :flag.case
		--label | -L )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--label]="$2"
				shift
				shift
			else
				printf "%s\n" "--label requires an argument: --label, -L COLOR"
				exit 1
			fi
			;;

		# :flag.case
		--no-gw | -G )
			# :flag.conflicts
			if [[ -n "${args[--clone-gw-from --vpn-over-tor]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from --vpn-over-tor"
				exit 1
			fi

			# :flag.case_no_arg
			args[--no-gw]=1
			shift
			;;

		# :flag.case
		--clone-gw-from )
			# :flag.conflicts
			if [[ -n "${args[--no-gw]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw"
				exit 1
			fi

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-gw-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW"
				exit 1
			fi
			;;

		# :flag.case
		--no-vpn | -V )
			# :flag.conflicts
			if [[ -n "${args[--clone-vpn-from --vpn-over-tor]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-vpn-from --vpn-over-tor"
				exit 1
			fi

			# :flag.case_no_arg
			args[--no-vpn]=1
			shift
			;;

		# :flag.case
		--clone-vpn-from )
			# :flag.conflicts
			if [[ -n "${args[--no-vpn]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-vpn"
				exit 1
			fi

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-vpn-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-vpn-from requires an argument: --clone-vpn-from VPN_GW"
				exit 1
			fi
			;;

		# :flag.case
		--vpn-over-tor )
			# :flag.conflicts
			if [[ -n "${args[--no-vpn --no-gw]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-vpn --no-gw"
				exit 1
			fi

			# :flag.case_no_arg
			args[--vpn-over-tor]=1
			shift
			;;

		# :flag.case
		--no-messenger | -M )
			# :flag.conflicts
			if [[ -n "${args[--clone-messenger-from]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-messenger-from"
				exit 1
			fi

			# :flag.case_no_arg
			args[--no-messenger]=1
			shift
			;;

		# :flag.case
		--clone-messenger-from )
			# :flag.conflicts
			if [[ -n "${args[--no-messenger]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-messenger"
				exit 1
			fi

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-messenger-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-messenger-from requires an argument: --clone-messenger-from MESSENGER_VM"
				exit 1
			fi
			;;

		# :flag.case
		--clone-web-from )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-web-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM"
				exit 1
			fi
			;;

		# :flag.case
		--clone-split-from )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-split-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[identity]+x} ]]; then
		printf "missing required argument: IDENTITY\nusage: risk identity create IDENTITY [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_identity_delete_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_delete_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity delete"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[identity]+x} ]]; then
		printf "missing required argument: IDENTITY\nusage: risk identity delete IDENTITY [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_identity_open_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_open_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity open"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[identity]+x} ]]; then
		printf "missing required argument: IDENTITY\nusage: risk identity open IDENTITY [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_identity_close_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_close_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity close"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_identity_start_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_start_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity start"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[identity]+x} ]]; then

				args[identity]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[identity]+x} ]]; then
		printf "missing required argument: IDENTITY\nusage: risk identity start IDENTITY [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_identity_stop_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_identity_stop_usage
		exit
		;;

	esac

	# :command.command_filter
	action="identity stop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_vpn_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_usage
		exit
		;;

	esac

	# :command.command_filter
	action=${1:-}

	case $action in
	-* )
		;;

	create )
		action="create"
		shift
		risk_vpn_create_parse_requirements "$@"
		shift $#
		;;

	setup )
		action="setup"
		shift
		risk_vpn_setup_parse_requirements "$@"
		shift $#
		;;

	start )
		action="start"
		shift
		risk_vpn_start_parse_requirements "$@"
		shift $#
		;;

	stop )
		action="stop"
		shift
		risk_vpn_stop_parse_requirements "$@"
		shift $#
		;;

	enable )
		action="enable"
		shift
		risk_vpn_enable_parse_requirements "$@"
		shift $#
		;;

	delete )
		action="delete"
		shift
		risk_vpn_delete_parse_requirements "$@"
		shift $#
		;;

	# :command.command_fallback
	"" )
		risk_vpn_usage
		exit 1
		;;

	* )
		printf "invalid command: %s\n" "$action"
		exit 1
		;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_vpn_create_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_create_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn create"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--name | -N )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--name]="$2"
				shift
				shift
			else
				printf "%s\n" "--name requires an argument: --name, -N NAME"
				exit 1
			fi
			;;

		# :flag.case
		--label | -L )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--label]="$2"
				shift
				shift
			else
				printf "%s\n" "--label requires an argument: --label, -L COLOR"
				exit 1
			fi
			;;

		# :flag.case
		--no-vpn | -V )
			# :flag.conflicts
			if [[ -n "${args[--clone-vpn-from --vpn-over-tor]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-vpn-from --vpn-over-tor"
				exit 1
			fi

			# :flag.case_no_arg
			args[--no-vpn]=1
			shift
			;;

		# :flag.case
		--clone-vpn-from )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--clone-vpn-from]="$2"
				shift
				shift
			else
				printf "%s\n" "--clone-vpn-from requires an argument: --clone-vpn-from VPN_GW"
				exit 1
			fi
			;;

		# :flag.case
		--vpn-over-tor )
			# :flag.conflicts
			if [[ -n "${args[--no-vpn --no-gw]:-}" ]]; then
				printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-vpn --no-gw"
				exit 1
			fi

			# :flag.case_no_arg
			args[--vpn-over-tor]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			printf "invalid argument: %s\n" "$key"
			exit 1

			;;

		esac
	done

}

# :command.parse_requirements
risk_vpn_setup_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_setup_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn setup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		# :flag.case
		--config-in | -c )

			# :flag.case_arg
			if [[ -n ${2+x} ]]; then

				args[--config-in]="$2"
				shift
				shift
			else
				printf "%s\n" "--config-in requires an argument: --config-in, -c CONFIG_VM"
				exit 1
			fi
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[vm]+x} ]]; then

				args[vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[vm]+x} ]]; then
		printf "missing required argument: VM\nusage: risk vpn setup VM [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_vpn_start_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_start_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn start"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[vm]+x} ]]; then

				args[vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[vm]+x} ]]; then
		printf "missing required argument: VM\nusage: risk vpn start VM [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_vpn_stop_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_stop_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn stop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[vm]+x} ]]; then

				args[vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[vm]+x} ]]; then
		printf "missing required argument: VM\nusage: risk vpn stop VM [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_vpn_enable_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_enable_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn enable"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[vm]+x} ]]; then

				args[vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[vm]+x} ]]; then
		printf "missing required argument: VM\nusage: risk vpn enable VM [options]\n"
		exit 1
	fi

}

# :command.parse_requirements
risk_vpn_delete_parse_requirements() {
	# :command.fixed_flags_filter
	case "${1:-}" in
	--help | -h )
		long_usage=yes
		risk_vpn_delete_usage
		exit
		;;

	esac

	# :command.command_filter
	action="vpn delete"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
		# :flag.case
		--verbose | -v )

			# :flag.case_no_arg
			args[--verbose]=1
			shift
			;;

		-?* )
			printf "invalid option: %s\n" "$key"
			exit 1
			;;

		* )
			# :command.parse_requirements_case
			# :command.parse_requirements_case_simple
			if [[ -z ${args[vm]+x} ]]; then

				args[vm]=$1
				shift
			else
				printf "invalid argument: %s\n" "$key"
				exit 1
			fi

			;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args[vm]+x} ]]; then
		printf "missing required argument: VM\nusage: risk vpn delete VM [options]\n"
		exit 1
	fi

}

# :command.initialize
initialize() {
	version="0.1.0"
	long_usage=''
	

	# src/initialize.sh
	#!/usr/bin/env bash

	# Connected terminal
	typeset -H _TTY
	GPG_TTY=$(tty)  # Needed for GPG operations
	export GPG_TTY

	# Remove verbose errors when * don't yield any match in ZSH
	setopt +o nomatch

	# Default templates and VMs to use

	typeset -rg WHONIX_GW_TEMPLATE="whonix-gw-16"
	typeset -rg WHONIX_WS_TEMPLATE="whonix-ws-16"

	# Working state and configurations
	typeset -rg RISK_DIR="${HOME}/.risk"                       # Directory where risk stores its state
	typeset -rg RISK_IDENTITIES_DIR="$RISK_DIR/identities"     # Idendities store their settings here

	#----------------------------#

	# Don't run as root
	if [[ $EUID -eq 0 ]]; then
		 echo "This script must be run as user"
		 exit 2
	fi

	# Use colors unless told not to
	{ ! option_is_set --no-color } && { autoload -Uz colors && colors }

	#----------------------------#

	[[ -e $RISK_DIR ]] || { mkdir -p $RISK_DIR && _message "Creating RISK directory in $RISK_DIR" }
	[[ -e $RISK_IDENTITIES_DIR ]] || mkdir -p $RISK_IDENTITIES_DIR

}

# :command.run
run() {
	declare -A args=()
	declare -a other_args=()
	declare -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	if [[ $action == "hush" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_hush_usage
		else
			risk_hush_command
		fi

	elif [[ $action == "hush attach" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_hush_attach_usage
		else
			risk_hush_attach_command
		fi

	elif [[ $action == "hush detach" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_hush_detach_usage
		else
			risk_hush_detach_command
		fi

	elif [[ $action == "backup" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_backup_usage
		else
			risk_backup_command
		fi

	elif [[ $action == "backup attach" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_backup_attach_usage
		else
			risk_backup_attach_command
		fi

	elif [[ $action == "backup detach" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_backup_detach_usage
		else
			risk_backup_detach_command
		fi

	elif [[ $action == "identity" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_usage
		else
			risk_identity_command
		fi

	elif [[ $action == "identity create" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_create_usage
		else
			risk_identity_create_command
		fi

	elif [[ $action == "identity delete" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_delete_usage
		else
			risk_identity_delete_command
		fi

	elif [[ $action == "identity open" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_open_usage
		else
			risk_identity_open_command
		fi

	elif [[ $action == "identity close" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_close_usage
		else
			risk_identity_close_command
		fi

	elif [[ $action == "identity start" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_start_usage
		else
			risk_identity_start_command
		fi

	elif [[ $action == "identity stop" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_identity_stop_usage
		else
			risk_identity_stop_command
		fi

	elif [[ $action == "vpn" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_usage
		else
			risk_vpn_command
		fi

	elif [[ $action == "vpn create" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_create_usage
		else
			risk_vpn_create_command
		fi

	elif [[ $action == "vpn setup" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_setup_usage
		else
			risk_vpn_setup_command
		fi

	elif [[ $action == "vpn start" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_start_usage
		else
			risk_vpn_start_command
		fi

	elif [[ $action == "vpn stop" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_stop_usage
		else
			risk_vpn_stop_command
		fi

	elif [[ $action == "vpn enable" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_enable_usage
		else
			risk_vpn_enable_command
		fi

	elif [[ $action == "vpn delete" ]]; then
		if [[ ${args[--help]:-} ]]; then
			long_usage=yes
			risk_vpn_delete_usage
		else
			risk_vpn_delete_command
		fi

	elif [[ $action == "root" ]]; then
		root_command
	fi
}

initialize
run "$@"
