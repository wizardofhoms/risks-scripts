#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
risk_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk - RISKS Dom0 management application\n"
    echo

  else
    printf "risk - RISKS Dom0 management application\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk [command]\n"
  printf "  risk [command] --help | -h\n"
  printf "  risk --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  hush       Manage the hush partition attach/detach from qubes"
  echo "  backup     Manage backup devices attach/detach from qubes"
  echo "  identity   Create, manage and use identities and/or use their machines"
  echo "  vpn        Create, configure, manage and use VPN gateways for an identity."
  echo "  config     Manage the risk global configuration"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"

    # :environment_variable.usage
    echo "  SDCARD_BLOCK"
    printf "    Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc\n"
    echo

    # :environment_variable.usage
    echo "  BACKUP_BLOCK"
    printf "    Qubes path to backup device, such as 'sys-usb:sdb1'\n"
    echo

    # :environment_variable.usage
    echo "  RISK_VPN_TEMPLATE"
    printf "    Default TemplateVM to use for VPN VMs\n"
    printf "    Default: sys-vpn\n"
    echo

    # :environment_variable.usage
    echo "  RISK_SPLIT_BROWSER_TEMPLATE"
    printf "    Default template to use for split-browser backend\n"
    echo

    # :environment_variable.usage
    echo "  RISK_WHONIX_WS"
    printf "    Default Whonix Workstation AppVM to use for identity client machine\n"
    echo

    # :environment_variable.usage
    echo "  RISK_VPN_VM"
    printf "    Default AppVM to use for cloning new VPN qubes\n"
    echo

    # :environment_variable.usage
    echo "  RISK_SPLIT_BROWSER"
    printf "    Default AppVM to clone for split-browser backend\n"
    echo

    # :environment_variable.usage
    echo "  RISK_DEFAULT_NETVM"
    printf "    Default VM to use as a firewall VM, to which either Tor or VPN gateways are\n    bound\n"
    printf "    Default: sys-firewall\n"
    echo

    # :environment_variable.usage
    echo "  VAULT_VM"
    printf "    Default vault VM\n"
    printf "    Default: vault\n"
    echo

  fi
}

# :command.usage
risk_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  else
    printf "risk hush - Manage the hush partition attach/detach from qubes\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk hush [command]\n"
  printf "  risk hush [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  attach   Attach the hush device to a qube. Accepts optional args to override default hush/vault"
  echo "  detach   Detach the hush device from its current qube, making sure it's not in a read-write state"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_hush_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  else
    printf "risk hush attach - Attach the hush device to a qube. Accepts optional args to override default hush/vault\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk hush attach [DEVICE] [VAULT_VM] [options]\n"
  printf "  risk hush attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --mount, -m"
    printf "    Mount the hush device in the vault (prompts for password)\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DEVICE"
    printf "    (optional) qubes path to device to use as hush (defaults to SDCARD_BLOCK)\n"
    echo

    # :argument.usage
    echo "  VAULT_VM"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_hush_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk hush detach - Detach the hush device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk hush detach\n"
  printf "  risk hush detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  else
    printf "risk backup - Manage backup devices attach/detach from qubes\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk backup [command]\n"
  printf "  risk backup [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  attach   Attach a backup device to a qube. Accepts optional args to override default backup/vault"
  echo "  detach   Detach the backup device from its current qube, making sure it's not in a read-write state"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_backup_attach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  else
    printf "risk backup attach - Attach a backup device to a qube. Accepts optional args to override default backup/vault\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk backup attach [DEVICE] [VAULT_VM] [options]\n"
  printf "  risk backup attach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  DEVICE"
    printf "    (optional) qubes path to device to use as backup (defaults to BACKUP_BLOCK)\n"
    echo

    # :argument.usage
    echo "  VAULT_VM"
    printf "    (optional) qube to use as vault VM (defaults to VAULT_VM)\n"
    echo

  fi
}

# :command.usage
risk_backup_detach_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  else
    printf "risk backup detach - Detach the backup device from its current qube, making sure it's not in a read-write state\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk backup detach\n"
  printf "  risk backup detach --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  else
    printf "risk identity - Create, manage and use identities and/or use their machines\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity [command]\n"
  printf "  risk identity [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  create   Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)"
  echo "  delete   Destroys an identity and all its associated machines and data"
  echo "  open     Simply open the identity store in the vault"
  echo "  close    Simply close the identity store in the vault"
  echo "  start    Start the identity in the vault and all of its enabled VMs"
  echo "  stop     Stops all machines belonging to an identity, and close its vault if active."
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_identity_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  else
    printf "risk identity create - Creates associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity create IDENTITY [options]\n"
  printf "  risk identity create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --name, -N NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    echo "  --label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    echo "  --no-gw, -G"
    printf "    Don't create a Whonix TOR gateway\n"
    echo

    # :flag.usage
    echo "  --clone-gw-from TOR_GW"
    printf "    Instead of creating the TOR gateway from a template, clone an existing TOR\n    AppVM\n"
    echo

    # :flag.usage
    echo "  --no-vpn, -V"
    printf "    Don't create a VPN gateway\n"
    echo

    # :flag.usage
    echo "  --clone-vpn-from VPN_GW"
    printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
    echo

    # :flag.usage
    echo "  --no-messenger, -M"
    printf "    Don't create a Messenger VM (for Signal and other message services)\n"
    echo

    # :flag.usage
    echo "  --clone-messenger-from MESSENGER_VM"
    printf "    Instead of creating the Messenger VM from a template, clone an existing\n    Messenger AppVM\n"
    echo

    # :flag.usage
    echo "  --clone-web-from WEB_VM"
    printf "    Instead of creating the Web browsing VM from a template, clone an existing\n    browser AppVM\n"
    echo

    # :flag.usage
    echo "  --clone-split-from SPLIT_BROWSER_VM"
    printf "    Instead of creating the split-browser VM from a template, clone an existing\n    one\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IDENTITY"
    printf "    Name of the identity for which to initialize infrastructure\n"
    echo

  fi
}

# :command.usage
risk_identity_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  else
    printf "risk identity delete - Destroys an identity and all its associated machines and data\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity delete IDENTITY [options]\n"
  printf "  risk identity delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity to delete along with machines\n"
    echo

  fi
}

# :command.usage
risk_identity_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  else
    printf "risk identity open - Simply open the identity store in the vault\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity open IDENTITY [options]\n"
  printf "  risk identity open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity to open in the vault\n"
    echo

  fi
}

# :command.usage
risk_identity_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  else
    printf "risk identity close - Simply close the identity store in the vault\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity close [options]\n"
  printf "  risk identity close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

  fi
}

# :command.usage
risk_identity_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  else
    printf "risk identity start - Start the identity in the vault and all of its enabled VMs\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity start IDENTITY [options]\n"
  printf "  risk identity start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  IDENTITY"
    printf "    Identity to start\n"
    echo

  fi
}

# :command.usage
risk_identity_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  else
    printf "risk identity stop - Stops all machines belonging to an identity, and close its vault if active.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity stop [options]\n"
  printf "  risk identity stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

  fi
}

# :command.usage
risk_identity_current_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  else
    printf "risk identity current - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk identity current\n"
  printf "  risk identity current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  else
    printf "risk vpn - Create, configure, manage and use VPN gateways for an identity.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn [command]\n"
  printf "  risk vpn [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  create    Create VPN gateway from a template, or by cloning an existing one."
  echo "  setup     Manage, import network configurations and run associated setup wizards"
  echo "  start     Start a VPN gateway in the background"
  echo "  stop      Stop a VPN gateway"
  echo "  enable    Automatically start a VPN gateway when starting the identity."
  echo "  disable   Do not autostart this VM when the identity is started"
  echo "  delete    Delete a VPN gateway"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_vpn_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  else
    printf "risk vpn create - Create VPN gateway from a template, or by cloning an existing one.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn create [VM] [options]\n"
  printf "  risk vpn create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --name, -N NAME"
    printf "    Use a different name for naming identity VMs\n"
    echo

    # :flag.usage
    echo "  --label, -L COLOR"
    printf "    Specify a label color to be used for all VMs belonging to this identity\n"
    echo

    # :flag.usage
    echo "  --enable, -E"
    printf "    Autostart this VM when the identity is started\n"
    echo

    # :flag.usage
    echo "  --template, -T TEMPLATE"
    printf "    TemplateVM to use instead of the default VPN TemplateVM\n"
    echo

    # :flag.usage
    echo "  --clone, -c"
    printf "    Instead of creating the VPN gateway from a template, clone an existing VPN\n    AppVM\n"
    echo

    # :flag.usage
    echo "  --from, -f VPN_GW"
    printf "    VM to clone instead of the default VPN_VM configuration setting\n"
    echo

    # :flag.usage
    echo "  --set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    echo "  --config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    echo "  --netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    (optional) name to use for this VM (=> name-vpn)\n"
    echo

  fi
}

# :command.usage
risk_vpn_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  else
    printf "risk vpn setup - Manage, import network configurations and run associated setup wizards\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn setup VM [options]\n"
  printf "  risk vpn setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :flag.usage
    echo "  --config-in CONFIG_VM"
    printf "    VM in which to browse for VPN configuration(s)\n"
    echo

    # :flag.usage
    echo "  --set-default"
    printf "    Set this VM as the default NetVM for all identity client VMs (browsers,\n    messaging, etc)\n"
    echo

    # :flag.usage
    echo "  --netvm, -n VM"
    printf "    NetVM to use for the gateway\n"
    echo

    # :flag.usage
    echo "  --choose"
    printf "    Choose an existing client config by running the setup wizard in the VPN VM\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to operate setup on\n"
    echo

  fi
}

# :command.usage
risk_vpn_start_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  else
    printf "risk vpn start - Start a VPN gateway in the background\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn start VM [options]\n"
  printf "  risk vpn start --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to start\n"
    echo

  fi
}

# :command.usage
risk_vpn_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  else
    printf "risk vpn stop - Stop a VPN gateway\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn stop VM [options]\n"
  printf "  risk vpn stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to stop\n"
    echo

  fi
}

# :command.usage
risk_vpn_enable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  else
    printf "risk vpn enable - Automatically start a VPN gateway when starting the identity.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn enable VM [options]\n"
  printf "  risk vpn enable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to enable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_disable_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  else
    printf "risk vpn disable - Do not autostart this VM when the identity is started\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn disable VM [options]\n"
  printf "  risk vpn disable --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to disable autostart for\n"
    echo

  fi
}

# :command.usage
risk_vpn_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  else
    printf "risk vpn delete - Delete a VPN gateway\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk vpn delete VM [options]\n"
  printf "  risk vpn delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  VM"
    printf "    gateway VM to delete\n"
    echo

  fi
}

# :command.usage
risk_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config - Manage the risk global configuration\n"
    echo

  else
    printf "risk config - Manage the risk global configuration\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config [command]\n"
  printf "  risk config [command] --help | -h\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  set     Set a configuration variable to a value"
  echo "  get     Print the value of a configuration variable"
  echo "  unset   Delete the value of a configuration variable"
  echo "  list    List all configuration variables"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  else
    printf "risk config set - Set a configuration variable to a value\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config set KEY VALUE\n"
  printf "  risk config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    echo "  VALUE"
    printf "    Value to assign to the key\n"
    echo

  fi
}

# :command.usage
risk_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  else
    printf "risk config get - Print the value of a configuration variable\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config get KEY\n"
  printf "  risk config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to show\n"
    echo

  fi
}

# :command.usage
risk_config_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  else
    printf "risk config unset - Delete the value of a configuration variable\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config unset KEY\n"
  printf "  risk config unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"

    # :argument.usage
    echo "  KEY"
    printf "    Name of of key to delete/unset\n"
    echo

  fi
}

# :command.usage
risk_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config list - List all configuration variables\n"
    echo

  else
    printf "risk config list - List all configuration variables\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config list\n"
  printf "  risk config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risk_config_keys_usage() {
  if [[ -n $long_usage ]]; then
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  else
    printf "risk config keys - List all configuration variables as an array (for completions)\n"
    echo

  fi

  printf "Usage:\n"
  printf "  risk config keys\n"
  printf "  risk config keys --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/config.sh
config_init() {
  RISK_CONFIG_FILE=${RISK_CONFIG_FILE-${RISK_DIR}/config.ini}
  [[ -f "$RISK_CONFIG_FILE" ]] || {

      _message "Writing default configuration file to ${RISK_CONFIG_FILE}"
      cat << EOF > "$RISK_CONFIG_FILE"

; RISKS Dom0 Configuration file

; You can either edit this file in place, set values
; through the 'risk config' command, or reload it with
; 'risk config reload'.
;
; Default Templates =============================================== #

; Default Whonix Workstation TemplateVM for TOR clients
WHONIX_WS_TEMPLATE=whonix-ws-16

; Default Whonix Gateway TemplateVM for TOR gateways
WHONIX_GW_TEMPLATE=whonix-gw-16

; Default TemplateVM to use for VPN VMs
VPN_TEMPLATE=sys-vpn

; Default TemplateVM to use for split-browser backend
SPLIT_BROWSER_TEMPLATE=

; Default AppVMs ================================================== #
;
; These VMs are used when we create new machines by cloning
; existing ones, instead of creating blank AppVMs from templates.

; Default Whonix Workstation AppVM to use for identity client machine
WHONIX_WS=

; Default AppVM to use for cloning new VPN qubes
VPN_VM=

; Default AppVM to clone for split-browser backend
SPLIT_BROWSER=

; Vault settings ================================================== #

; Default vault VM
VAULT_VM=vault

; Qubes path to hush device, such as 'dom0:mmcblk01', or 'sys-usb:sda2', etc
SDCARD_BLOCK=

; Qubes path to backup device, such as 'sys-usb:sdb1'
BACKUP_BLOCK=

; Other network settings ========================================= #

; Default VM to use as a firewall VM, to which either Tor or VPN gateways are bound
DEFAULT_NETVM=sys-firewall

; Default path to VPN client config in VPN VM, to be loaded when the service
; starts. This path is the default one used by qubes-vpn-support installs.
DEFAULT_VPN_CLIENT_CONF='/rw/config/vpn/vpn-client.conf'

EOF
  }
}

config_get() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[2]}" # Changed to 2 because ZSH indexes start at 1
      break
    fi
  done < "$RISK_CONFIG_FILE"

  echo "$value"
}

config_set() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[2]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$RISK_CONFIG_FILE"

  printf "%b\n" "$output" > "$RISK_CONFIG_FILE"
}

config_show() {
  config_init
  cat "$RISK_CONFIG_FILE"
}

config_keys() {
  # zsh compat
  setopt local_options BASH_REMATCH

  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      key="${key//\=/}"
      [[ -n "$key" ]] && keys+=("$key")
    fi
  done < "$RISK_CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/device.sh

# Checks that a given device is attached to a given VM
check_is_device_attached ()
{
    local block="$1"
    local vm="$2"

    local ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
    if [[ ${#ovm} -eq 0 ]] || [[ ${ovm} != "$vm" ]]; then
        _failure "Device block $block is not mounted on vault ${vm}"
    fi
}

# src/lib/identity.sh

# Upon unlocking a given identity, sets the name as an ENV

# variable that we can use in further functions and commands.
# $1 - The name to use. If empty, just resets the identity.
_set_active_identity ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISK_IDENTITY_FILE} ]]; then
        identity=$(cat "${RISK_IDENTITY_FILE}")
        rm "${RISK_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

        _verbose "Identity '${identity}' is now inactive, (name file deleted)"
        _message "Identity '${identity}' is now INACTIVE"
        return
    fi

    # If we don't have a file containing the

    # identity name, populate it.
    if [[ ! -e ${RISK_IDENTITY_FILE} ]]; then
        print "$1" > "${RISK_IDENTITY_FILE}"
	fi

    _verbose "Identity '${1}' is now active (name file written)"
    _message "Identity '${1}' is now ACTIVE"
}

# Returns 0 if an identity is unlocked, 1 if not.
_identity_active ()

{
    local identity

    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
    if [[ -z "${active_identity}" ]]; then
        return 1
	fi

    return 0
}

# Given an argument potentially containing the active identity, checks
# that either an identity is active, or that the argument is not empty.
# $1 - An identity name
# Exits the program if none is specified, or echoes the identity if found.
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
_identity_active_or_specified ()
{
    local active_identity

    if [[ -z "${1}" ]] ; then
        active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
        if [[ -z "${active_identity}" ]]; then
            return 1
        fi
    fi

    # Print the identity
    if [[ -n "${1}" ]]; then
        print "${1}" && return
    fi

    print "$active_identity"
}

# _set_identity is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
#
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
_set_identity ()

{
    local identity="$1"

    # This will throw an error if we don't have an identity from any source.
    IDENTITY=$(_identity_active_or_specified "$identity")
    _catch "Command requires either an identity to be active or given as argument"

    # Set the identity directory
    IDENTITY_DIR="${RISK_IDENTITIES_DIR}/${IDENTITY}"
}

# check that no identity is active in the vault, and fail if there is.
check_no_active_identity ()
{
    active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
    if [[ -n $active_identity ]]; then
        # It might be the same
        if [[ $active_identity == "$1" ]]; then
            _message "Identity $1 is already active"
            exit 0
        fi

        _failure "Identity $active_identity is active. Close/slam/fold it and rerun this command"
    fi
}

# Get the default VM label/color for an identity
get_identity_label ()
{
    cat "${IDENTITY_DIR}/vm_label" 2>/dev/null
}

# _identity_proxies returns an array of proxy VMs

# (VPNs and TOR gateways for the current identity)
_identity_proxies ()
{
    [[ -f "${IDENTITY_DIR}/proxy_vms" ]] || return
    read -d '' -r -A proxies <"${IDENTITY_DIR}/proxy_vms"
    echo "${proxies[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_client_vms ()
{
    [[ -f "${IDENTITY_DIR}/client_vms" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/client_vms"
    echo "${clients[@]}"
}

# returns all identity VMs that are not gateways/proxies,
# but are potentially (most of the time) accessing network
# from one or more of these gateways.
_identity_autostart_vms ()
{
    [[ -f "${IDENTITY_DIR}/autostart_vms" ]] || return
    read -d '' -r -A clients <"${IDENTITY_DIR}/autostart_vms"
    echo "${clients[@]}"
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risk'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Simple way of setting the section and to update the padding
_in_section ()
{
    section="$1"
    if [[ -n "${2}" ]]; then
        section_padding="$2"
    fi
}


function is_verbose_set () {
    if [[ "${args[--verbose]}" -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

# Messaging function with pretty coloring
function _msg()

{
    # Check if we have been provided a section name,

    # and if not, that the section is set to a default.
    if [[ ${#@} -lt 3 ]]; then
        local progname="$section"
        if [[ -z "$progname" ]]; then
            progname='risks'
        fi
        local msg="$2"
    else
        local progname="$2"
        local msg="$3"
    fi

    # Padd the program/section name
    progname="$(printf %"${section_padding}"s "${progname}")"

    # Apply any translation for non-english users
	# local i
	# command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
	# for i in {3..${#}}; do
	# 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
	# done

	local command="print -P"
	local pchars=""
	local pcolor="normal"
	local fd=2
	local -i returncode

	case "$1" in
		inline)
			command+=" -n"; pchars=" > "; pcolor="yellow"
			;;
		message)
			pchars=" . "; pcolor="white"
			;;
		verbose)
			pchars="[D]"; pcolor="blue"
			;;
		success)
			pchars="(*)"; pcolor="green"
			;;
		warning)
			pchars="[W]"; pcolor="yellow"
			;;
		failure)
			pchars="[E]"; pcolor="red"
			returncode=1
			;;
		print)
			progname=""
			fd=1
			;;
		*)
			pchars="[F]"; pcolor="red"
			msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
			returncode=127
			;;
	esac

	[[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

    # If there is a log-file specified with flag --log-file,
    # output the message to it, instead of the current file descriptor
    logfile="${args[--log-file]}"
    if [[ -n "${logfile}" ]]; then
        ${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
        return $returncode
    fi

    # Else, print to stdout, with colors
	if [[ -t $fd ]]; then
       [[ -n "$progname" ]] && progname="$fg[magenta]$progname$reset_color"
       [[ -n "$pchars" ]] && pchars="$fg_bold[$pcolor]$pchars$reset_color"
       msg="$fg[$pcolor]$msg$reset_color"
	fi

    ${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
	return $returncode
}

function _message() {
	local notice="message"
	[[ "$1" = "-n" ]] && shift && notice="inline"
    option_is_set -q || _msg "$notice" "$@"
	return 0
}

function _verbose() {
    is_verbose_set && _msg verbose "$@"
	return 0
}

function _success() {
    option_is_set -q || _msg success "$@"
	return 0
}

function _warning() {
    option_is_set -q || _msg warning "$@"
	return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()

{
	typeset -i exitcode=${exitv:-1}

    _msg failure "$@"
    if [[ -n "$COMMAND_STDERR" ]]; then
        _msg inline "$COMMAND_STDERR"
    fi

	# Be sure we forget the secrets we were told
    exit "$exitcode"
}

# function _failure() {
# 	typeset -i exitcode=${exitv:-1}
#     option_is_set -q || _msg failure "$@"
# 	# be sure we forget the secrets we were told
#     exit "$exitcode"
# }

function _print() {
    option_is_set -q || _msg print "$@"
	return 0
}

# src/lib/messenger.sh

# Creates a new Messaging AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this VM

# $3 - Label
create_messenger_vm ()
{
    local msg="${1}-msg"
    local netvm="${2-$RISK_DEFAULT_NETVM}"
    local gw_label="${3-orange}"

    local -a create_command
    create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$WHONIX_WS_TEMPLATE")

    _message "Creating messaging VM (name: $msg / netvm: $netvm / template: $WHONIX_WS_TEMPLATE)"
}

# very similar to create_messenger_vm , except that we clone

# an existing AppVM instead of creating a new one from a Template.
clone_messenger_vm ()
{
    local msg="${1}-msg"
    local gw_clone="$2"
    local netvm="${3-$RISK_DEFAULT_NETVM}"
    local gw_label="${4-orange}"

    create_command+=(qvm-clone "${gw_clone}" "${msg}")

    local label_command=(qvm-prefs "$msg" label "$gw_label")
    local netvm_command=(qvm-prefs "$msg" netvm "$netvm")

    _message "Cloning messaging VM (name: $msg / netvm: $netvm / template: $gw_clone)"
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
    # The STDOUT/STDERR variables are populated, which
    # makes their content available to any subsequent call
    # to _failure, which needs STDERR output
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully. We check that either
    # stdout or stderr are non-empty: sometimes commands might
    # output to stderr, like wipe.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    # Return the command's exit code
    return $ret
}

# run a command in a qube
# $1 - Qube name
# $@ - Command string to run
_qrun () {
    local vm="$1"
    shift
    local command="$*"

    # Prepare the full command
    local xterm_command='zsh -c "'"$command"'"'
    local full_command=(qvm-run --pass-io "$vm" xterm -e "$xterm_command")

    _verbose "Running command: ${full_command[*]}"

    # Split io like in _run, and store the return value
    # Note that we don't double quote the $full_command variable.
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$(${full_command[@]})" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully like in _run also.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    return $ret
}

_qvrun () {
    local vm="$1"
    shift
    local full_command="$*"

    _verbose "Running command: ${full_command[*]}"

    # Run the command raw, so that we get the output as it is.
    qvm-run --pass-io "$vm" "${full_command[*]}"
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
    local ret="$?"

    if [[ ! $ret -eq 0 ]]; then
        _failure "$@"
    fi
}

#assertRunning [vm] [start]
#Assert that the given VM is running. Will unpause paused VMs and may start shut down VMs.
#[vm]: VM for which to make sure it's running.
#[start]: If it's not running and not paused, start it (default: 0/true). If set to 1, this function will return a non-zero exit code.
#returns: A non-zero exit code, if it's not running and/or we failed to start the VM.
function assertRunning {
    local vm="$1"
    local start="${2:-0}"

    #make sure the VM is unpaused
    if qvm-check --paused "$vm" &> /dev/null ; then
        qvm-unpause "$vm" &> /dev/null || return 1
    else
        if [ $start -eq 0 ] ; then
            qvm-start --skip-if-running "$vm" &> /dev/null || return 1
        else
            #we don't attempt to start
            return 2
        fi
    fi

    return 0
}

# start_vm [vm 1] ... [vm n]
#Start the given VMs without executing any command.
function start_vm {
    local ret=0

    local vm=
    declare -A pids=() #VM --> pid
    for vm in "$@" ; do
        [[ "$vm" == "dom0" ]] && continue
        _verbose "Starting: $vm"
        assertRunning "$vm" &
        pids["$vm"]=$!
    done

    local failed=""
    local ret=
    for vm in "${(@k)pids}" ; do
        wait "${pids["$vm"]}"
        ret=$?
        [ $ret -ne 0 ] && failed="$failed"$'\n'"$vm ($ret)"
    done

    [ -z "$failed" ] || _verbose "Starting the following VMs failed: $failed"

    #set exit code
    [ -z "$failed" ]
}

# shutdown_vm [vm 1] ... [vm n]
#Shut the given VMs down.
function shutdown_vm {
    local ret=0

    if [ $# -gt 0 ] ; then
        #make sure the VMs are unpaused
        #cf. https://github.com/QubesOS/qubes-issues/issues/5967
        local vm=
        for vm in "$@" ; do
            qvm-unpause "$vm" &> /dev/null
        done

        _verbose "Shutting down: $*"
        qvm-shutdown --wait "$@"
        ret=$?
    fi

    return $ret
}

# src/lib/tor_gateway.sh

# Creates a new TOR Whonix gateway AppVM.
# $1 - Name to use for new VM
# $2 - Netvm for this gateway
# $3 - Label
create_tor_gateway ()
{
    local gw="${1}-gw"
    local netvm="${2-$RISK_DEFAULT_NETVM}"
    local gw_label="${3-yellow}"

    local -a create_command
    create_command+=(qvm-create --property netvm="$netvm" --label "$gw_label" --template "$WHONIX_GW_TEMPLATE")

    _message "Creating TOR gateway VM (name: $gw / netvm: $netvm / template: $WHONIX_GW_TEMPLATE)"
}

# very similar to create_tor_gateway, except that we clone an existing
# gateway AppVM instead of creating a new one from a Template.
clone_tor_gateway ()
{
    local gw="${1}-gw"
    local gw_clone="$2"
    local netvm="${3-$RISK_DEFAULT_NETVM}"
    local gw_label="${4-yellow}"

    create_command+=(qvm-clone "${gw_clone}" "${gw}")

    local label_command=(qvm-prefs "$gw" label "$gw_label")
    local netvm_command=(qvm-prefs "$gw" netvm "$netvm")

    _message "Cloning TOR gateway VM (name: $gw / netvm: $netvm / template: $gw_clone)"
}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
option_is_set() {
	local -i r	 # the return code (0 = set, 1 = unset)

	[[ -n ${(k)OPTS[$1]} ]];
	r=$?

	[[ $2 == "out" ]] && {
		[[ $r == 0 ]] && { print 'set' } || { print 'unset' }
	}

	return $r;
}

# Retrieves the value of a variable first by looking in the risk
# config file, and optionally overrides it if the flag is set.
# $1 - Flag argument
# $2 - Key name in config
config_or_flag ()

{
    local value config_value

    config_value=$(config_get $2)   # From config
    value="${1:=$config_value}"      # overriden by flag if set

    print $value
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# src/lib/validations/validate_devices.sh

validate_device () {
    local block="$1"

    # And check not already attached to another qube
    ovm=$(qvm-block list | grep "${block}" | awk {'print $4'} | cut -d" " -f1)
    if [[ ${#ovm} -gt 0 ]]; then

        # if [ "${ovm}" == "${vm}" ]; then
        #     echo "Block ${SDCARD_BLOCK} is already attached to ${vm}"
        #     exit 0
        # fi

        echo -e "Block ${SDCARD_BLOCK} is currently attached to ${ovm}."
        echo "Please umount it properly from there and rerun this program."
        return

        # slam tombs open in the vm
        #qvm-run -u user ${ovm} '/usr/local/bin/tomb slam all'

        # umount sdcard from the vm
        #qvm-run -u user ${ovm} '/usr/local/bin/risks umount sdcard'

        # detach the sdcard
        #qvm-block detach ${ovm} ${block}
            #if [ $? != 0 ]; then
        #	echo "Block ${block} can not be detached from ${ovm}. Aborted."
        #	exit
        #fi

    fi
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/validations/validate_vm.sh

# does the vm exist?
validate_vm_exists () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi
}

# Checks that the vault VM obeys a few requirements, like no network
validate_valid_vaultvm () {
    vm=""
    for item in $(qvm-ls | grep -v dom0 | awk '{print $1}' | grep "${1}")
    do
        if [ "${item}" == "${1}" ]; then
            vm=${1}
        fi
    done
    if [ ${#vm} -eq 0 ]; then
        echo "No vm with name ${1} exists or can not be used. Aborted."
        return
    fi

    netvm=$(qvm-prefs "${vm}" | grep "netvm" | awk '{print $3}')
    if [ "${netvm}" != "None" ]; then
        echo "${vm} might be connected to the internet. Aborted."
        echo "Check: qvm-prefs ${vm} | grep netvm"
    fi
}

# src/lib/vpn_gateway.sh

# Creates a new VPN gateway from a TemplateVM
create_vpn_gateway ()
{
    local gw="${1}"
    local netvm="${2:=$DEFAULT_NETVM}"
    local gw_label="${3:=blue}"
    local template="${4:=$VPN_TEMPLATE}"

    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / template: $template)"
    qvm-create --property netvm="$netvm" --label "$gw_label" --template "$template"

    _message "Getting network from $netvm"

    # Add the gateway to the list of existing proxies for this identity
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# Creates a new VPN gateway from an existing VPN AppVM

clone_vpn_gateway ()
{
    local gw="${1}"
    local netvm="${2:=$DEFAULT_NETVM}"
    local gw_label="${3:=blue}"
    local gw_clone="$4"

    # Create the VPN
    _verbose "VPN gateway properties (name: $gw / netvm: $netvm / clone: $gw_clone)"
    _run qvm-clone "${gw_clone}" "${gw}"
    _catch "Failed to clone VM ${gw_clone}"

    # For now disposables are not allowed, since it would create too many VMs,

    # and complicate a bit the setup steps for VPNs. If the clone is a template
    # for disposables, unset it
    local disp_template
    disp_template=$(qvm-prefs "${gw}" template_for_dispvms)
    [[ "$disp_template" = "True" ]] && qvm-prefs "${gw}" template_for_dispvms False

    # _message "Getting network from $netvm"
    qvm-prefs "$gw" netvm "$netvm"

    _verbose "Setting label to $gw_label"
    qvm-prefs "$gw" label "$gw_label"

    # Add the gateway to the list of existing proxies for this identity
    echo "$gw" >> "${IDENTITY_DIR}/proxy_vms"
}

# function to browse for one or more (as zip) VPN client configurations
# in another VM, import them in our VPN VM, and run the setup wizard if
# there is more than one configuration to choose from.
# $1 - Name of VPN VM
# $2 - Name of VM in which to browse for configuration
# $ $3 - Path to the VPN client config to which one (only) should be copied, if not a zip file
import_vpn_configs ()
{
    local name="$1"
    local config_vm="$2"
    local client_conf_path="$3"

    config_path=$(_qvrun "$config_vm" "zenity --file-selection --title='VPN configuration selection' 2>/dev/null")
    if [[ -z "$config_path" ]]; then
        _message "Canceling setup: no file selected in VM $config_vm"
    else
        _verbose "Copying file $config_path to VPN VM"
        _qvrun "$config_vm" qvm-copy-to-vm "$name" "$config_path"

        # Now our configuration is the QubesIncoming directory of our VPN,
        # so we move it where the VPN will look for when starting.
        local new_path="/home/user/QubesIncoming/${config_vm}/$(basename "$config_path")"

        # If the file is a zip file, unzip it in the configs directory
        # and immediately run the setup prompt to choose one.
        if [[ $new_path:t:e == "zip" ]]; then
            local configs_dir="/rw/config/vpn/configs"

            _verbose "Unzipping files into $configs_dir"
            _qvrun "$name" mkdir -p "$configs_dir"

            _qvrun "$name" unzip -j -d "$configs_dir"

            _qvrun "$name" /usr/local/bin/setup_VPN

        else
            _verbose "Copying file directly to the VPN client config path"
            _qvrun "$name" mv "$new_path" "$client_conf_path"
        fi

        _message "Done transfering VPN client configuration to VM"
    fi

    # Add the gateway to the list of existing proxies for this identity
    echo "$gw" > "${IDENTITY_DIR}/proxy_vms"
}

# get_next_vpn_name returns a name for a new VPN VM, such as vpn-1,
# where the number is the next value after the ones found in existing
# VPN vms.
get_next_vpn_name ()
{
    local base_name="$1"

    # First get the array of ProxyVMs names
    local proxies=($(_identity_proxies))

    local next_number=1

    for proxy in "${proxies[@]}"; do
        if contains "$proxy" "vpn-"; then
            next_number=$((next_number + 1))
        fi
    done

    print "$1-vpn-$next_number"
}

# src/lib/web.sh

# Create a web browsing VM from a template
create_browser_vm ()
{
    local web="${1}-web"
    local netvm="${2-$RISK_DEFAULT_NETVM}"
    local web_label="${3-orange}"

    _message "Creating web VM (name: $web / netvm: $netvm / template: $WHONIX_WS_TEMPLATE)"
    qvm-create --property netvm="$netvm" --label "$web_label" --template "$WHONIX_WS_TEMPLATE"
    [[ ! $? -eq 0 ]] && _warning "Failed to create browser VM $web"

    # Mark this VM as a disposable template, and tag it with our identity
    qvm-prefs "${web}" template_for_dispvms True
    qvm-tags "$web" set "$IDENTITY"
}

# Clone a web browsing VM from an existing one
clone_browser_vm ()
{
    local web="${1}-web"
    local web_clone="$2"
    local netvm="${3-$RISK_DEFAULT_NETVM}"
    local web_label="${4-orange}"

    _message "Cloning web VM (name: $web / netvm: $netvm / template: $web_clone)"
    qvm-clone "${web_clone}" "${web}"
    [[ ! $? -eq 0 ]] && _warning "Failed to clone browser VM $web" && return

    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm "$netvm"

    # Mark this VM as a disposable template, and tag it with our identity
    qvm-prefs "${web}" template_for_dispvms True
    qvm-tags "$web" set "$IDENTITY"
}

# Create a split-browser VM from a template
create_split_browser_vm ()
{
    local web="${1}-split-web"
    local web_label="${2-gray}"

    _message "Creating split-browser (name: $web / netvm: $netvm / template: $RISK_SPLIT_BROWSER_TEMPLATE)"
    qvm-create --property netvm=None --label "$web_label" --template "$RISK_SPLIT_BROWSER_TEMPLATE"
}

# Clone an existing split-browser VM, and change its dispvms
clone_split_browser_vm ()
{
    local web="${1}-split-web"
    local web_clone="$2"
    local web_label="${3-gray}"

    _message "Cloning split-browser VM (name: $web / netvm: $netvm / template: $web_clone)"
    qvm-clone "${web_clone}" "${web}"

    qvm-prefs "$web" label "$web_label"
    qvm-prefs "$web" netvm None
}

# :command.command_functions

# :command.function
risk_hush_attach_command() {
  # src/hush_attach_command.sh

  local block vm

  block="${args[device]-$SDCARD_BLOCK}"
  vm="${args[vault_vm]-$VAULT_VM}"

  # If the validations were not performed because

  # we use a default environment variable for the
  # vault VM, perform them again here.
  local error_invalid_vm=$(validate_valid_vaultvm "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  local error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep "^"${vm}"$" &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 15
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_failure "Block ${block} can not be attached to ${vm}"
  fi

  # If user wants to mount it now, do it
  if [[ ${args[--mount]} -eq 1 ]]; then
      _message "Mounting hush device"
      _qrun "$vm" risks hush mount
  fi

}

# :command.function
risk_hush_detach_command() {
  # src/hush_detach_command.sh

  local block vm

  block="${args[device]-$SDCARD_BLOCK}"
  vm="${args[vault_vm]-$VAULT_VM}"

  # First unmount the hush device in vault
  _qrun "$vm" risks hush umount
  _catch "Failed to unmount hush device ($block)"

  # finally attach the sdcard encrypted partition to the qube
  qvm-block detach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been detached from ${vm}"
  else
  	_failure "Block ${block} can not be detached from ${vm}"
  fi

}

# :command.function
risk_backup_attach_command() {
  # src/backup_attach_command.sh

  local block vm

  block="${args[device]-$BACKUP_BLOCK}"
  vm="${args[vault_vm]-$VAULT_VM}"

  # If the validations were not performed because

  # we use a default environment variable for the
  # vault VM, perform them again here.
  local error_invalid_vm=$(validate_vm_exits "$vm")
  if [[ -n "$error_invalid_vm" ]]; then
      _failure "$error_invalid_vm"
  fi

  # Do the same for the hush device
  local error_device=$(validate_device "$block")
  if [[ -n "$error_device" ]]; then
      _failure "$error_device"
  fi

  # is the vm running?
  qvm-ls | grep Running | awk {'print $1'} | grep "^"${vm}"$" &> /dev/null
  if [ "$?" != "0" ]; then
      _verbose "Starting VM $vm"
      qvm-start "${vm}"
  	sleep 15
  fi

  # finally attach the sdcard encrypted partition to the qube
  qvm-block attach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${block} has been attached to ${vm}"
  else
  	_success "Block ${block} can not be attached to ${vm}"
  fi

}

# :command.function
risk_backup_detach_command() {
  # src/backup_detach_command.sh
  local block="${args[device]:-$BACKUP_BLOCK}"
  local vm="${VAULT_VM}"

  qvm-block detach "${vm}" "${block}"
  if [[ $? -eq 0 ]]; then
  	_success "Block ${SDCARD_BLOCK} has been detached from to ${vm}"
  else
  	_success "Block ${SDCARD_BLOCK} can not be detached from ${vm}"
  fi

}

# :command.function
risk_identity_create_command() {
  # src/identity_create_command.sh

  # Base identity parameters, set globally.
  local name="${args[name]}"
  local expiry="${args[expiry_date]}"
  local email="${args[email]}"
  local pendrive="${args[backup_device]}"

  # Propagate the identity and its settings
  _set_identity "${args[identity]}"

  # Identity checks and basic setup ==========================================

  # First open the identity, because we might need its credentials and stuff
  # The identity argument is here, so this command has the arguments it needs
  active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
  if [[ -n $active_identity ]]; then
      # It might be the same
      if [[ $active_identity != "$IDENTITY" ]]; then
          _failure "Another identity ($IDENTITY) is active. Close/slam/stop it and rerun this command"
      fi
  else
      risk_open_identity_command
      _catch "Failed to open identity $IDENTITY"
  fi

  # Make a directory for this identity, and store the associated VM name
  [[ -e ${IDENTITY_DIR} ]] || mkdir -p "$IDENTITY_DIR"

  # Else we're good to go
  _message "Creating identity $IDENTITY and infrastructure"

  # Default settings and values

  # If the user wants to use a different vm_name for the VMs
  local vm_name="${args[--name]-$IDENTITY}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_name"

  _message "Using vm_name '$name' as VM base name"

  local label="${args[--label]}"
  echo "$vm_name" > "${IDENTITY_DIR}/vm_label"

  _message "Using label '$label' as VM default label"

  # Prepare the root NetVM for this identity
  local netvm="${DEFAULT_NETVM}"

  # Create identity in vault =================================================

  # Simply pass the arguments to the vault
  _message "Creating identity in vault"
  _qrun "$VAULT_VM" risks create identity "$name" "$email" "$expiry" "$pendrive"
  _catch "Failed to create identity in vault"

  # Then, open it
  _qrun "$VAULT_VM" risks open identity "$name"
  _catch "Failed to open identity in vault"

  # Network VMs ==============================================================
  _message "Creating network VMs:"

  # 1 - Tor gateway, if not explicitly disabled
  if [[ ${args[--no-gw]} -eq 0 ]]; then
      local gw_netvm="$netvm"

      # We either clone the gateway from an existing one,
      # or we create it from a template.
      if [[ -n ${args[--clone-gw-from]} ]]; then
          local clone="${args[--clone-gw-from]}"
          clone_tor_gateway "$vm_name" "$clone" "$gw_netvm" "$label"
      else
          create_tor_gateway "$vm_name" "$gw_netvm" "$label"
      fi

      # Set it as the netvm for this identity, and for the rest of the VMs
      echo "$vm_name" > "${IDENTITY_DIR}/net_vm"

  else
      _message "Skipping TOR gateway"
  fi

  # 2 - VPNs, if not explicitly disabled
  if [[ ${args[--no-vpn]} -eq 0 ]]; then
      local vpn_netvm="$(cat "${IDENTITY_DIR}/net_vm" )"

      # We either clone the gateway from an existing one,
      # or we create it from a template.
      if [[ -n ${args[--clone-vpn-from]} ]]; then
          local clone="${args[--clone-vpn-from]}"
          clone_vpn_gateway "$vm_name" "$clone" "$vpn_netvm" "$label"
      else
          create_vpn_gateway "$vm_name" "$vpn_netvm" "$label"
      fi

      # Set it as the netvm for this identity
      echo "$vm_name" > "${IDENTITY_DIR}/net_vm"

  else
      _message "Skipping VPN gateway"
  fi

  # At this point we should know the vm_name of the VM to be used as NetVM
  # for the subsquent machines, such as web browsing and messaging VMs.

  # Message VMs ==============================================================
  _message "Creating messaging VMs:"

  # if [[ ${args[--no-messenger]} -eq 0 ]]; then
  #     local msg="${vm_name}-msg"
  # else
  #     _message "Skipping messaging VM"
  # fi

  # Browser VMs ==============================================================
  _message "Creating web VMs:"

  # Browser VMs are disposable, but we make a template for this identity,
  # since we might  either modify stuff in there, and we need them at least

  # to have a different network route.
  if [[ -n ${args[--clone-web-from]} ]]; then
      local web_netvm="$(cat "${IDENTITY_DIR}/net_vm")"

      local clone="${args[--clone-web-from]}"
      clone_browser_vm "$vm_name" "$clone" "$web_netvm" "$label"
  else
      create_browser_vm "$vm_name" "$web_netvm" "$label"
  fi

  # Split-browser has its own dispVMs and bookmarks
  local split_web="${vm_name}-split-web"
  if [[ -n ${args[--clone-split-from]} ]]; then
      local clone="${args[--clone-split-from]}"
      clone_split_browser_vm "$vm_name" "$clone" "$label"
  else
      create_split_browser_vm "$vm_name" "$label"
  fi

  _success "Successfully initialized infrastructure for identity $IDENTITY"

}

# :command.function
risk_identity_delete_command() {
  # src/identity_delete_command.sh

  _set_identity "${args[identity]}"

}

# :command.function
risk_identity_open_command() {
  # src/identity_open_command.sh

  _set_identity "${args[identity]}"

  # 1 - Check that hush is mounted on vault
  # TODO: change this, since it only checks for the default vault VM
  check_is_device_attached "${SDCARD_BLOCK}" "${VAULT_VM}"

  # 2 - Check that no identity is currently opened
  # The second line should be empty, as opposed to being an encrypted coffin name
  check_no_active_identity "$IDENTITY"

  # 3 - Send commands to vault
  _message "Opening identity $IDENTITY"

  _qrun "$VAULT_VM" risks open identity "$IDENTITY"
  _catch "Failed to open identity"

  _message "Identity $IDENTITY is active"

}

# :command.function
risk_identity_close_command() {
  # src/identity_close_command.sh

  # Check we have an active identity
  active_identity=$(qvm-run --pass-io "$VAULT_VM" 'cat .identity' 2>/dev/null)
  if [[ -z $active_identity ]]; then
      _message "No active identity to close"
      exit 0
  fi

  _message "Closing identity $active_identity"

  _qrun "$VAULT_VM" risks close identity "$active_identity"
  _catch "Failed to close identity $active_identity"

  _message "Identity $active_identity is closed"

}

# :command.function
risk_identity_start_command() {
  # src/identity_start_command.sh

  _set_identity "${args[identity]}"

  # Get the name for VMs
  local identity_dir="${IDENTITY_DIR}"
  local name="$(cat "${identity_dir}/vm_name")"

}

# :command.function
risk_identity_stop_command() {
  # src/identity_stop_command.sh
  echo "# this file is located in 'src/identity_stop_command.sh'"
  echo "# code for 'risk identity stop' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
risk_identity_current_command() {
  # src/identity_current_command.sh
  # Simply print the active identity in the vault
  _identity_active_or_specified

}

# :command.function
risk_vpn_create_command() {
  # src/vpn_create_command.sh

  _set_identity

  # Prepare some settings for this new VM
  local name netvm clone template label config

  name="${args[vm]:-$(cat "${IDENTITY_DIR}/vm_name" 2>/dev/null)}"
  label="${args[--label]:=$(get_identity_label)}"
  netvm="$(config_or_flag "${args[--netvm]}" DEFAULT_NETVM)"
  clone="$(config_or_flag "${args[--from]}" VPN_VM)"
  template="$(config_or_flag "${args[--template]}" VPN_TEMPLATE)"
  config_vm="${args[--config-in]}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"

  # 0 - Last-time setup

  # If the --name flag is empty, this means we are using a default one,
  # either the configured default one, or the name of the identity.

  # In this case, we add 'vpn-1' to it (number varying).
  if [[ -z "${args[vm]}" ]]; then
      name="$(get_next_vpn_name "$name")"
  fi

  # 1 - Creation
  #
  # We either clone the gateway from an existing one,
  # or we create it from a template.
  if [[ "${args[--clone]}" -eq 1 ]]; then
      _message "Cloning VPN gateway (from VM $clone)"
      clone_vpn_gateway "$name" "$netvm" "$label" "$clone"

  else
      _message "Creating VPN gateway (from template $template)"
      create_vpn_gateway "$name" "$netvm" "$label" "$template"
  fi

  # 2 - Setup
  #
  # Simply run the setup command, which has access to all the flags
  # it needs to do its job. Tweak the args array for this to work.
  args[vm]="$name"
  risk_vpn_setup_command

  # If the VM is marked autostart
  if [[ -n ${args[--enable]} ]]; then

      _verbose "Enabling VM to autostart"
      risk_vpn_enable_command
  fi

  _message "Done creating VPN gateway $name"

}

# :command.function
risk_vpn_setup_command() {
  # src/vpn_setup_command.sh

  _set_identity

  local name config_vm client_conf_path netvm

  name="${args[vm]}"
  config_vm="${args[--config-in]}"
  client_conf_path="$(config_or_flag "" DEFAULT_VPN_CLIENT_CONF)"
  netvm="$(config_or_flag "${args[--netvm]}" DEFAULT_NETVM)"

  # There are different ways to setup a VPN VM, often mutually exclusive.

  # We might be asked to change the netVM, but this can be combined
  # with other settings to be handled below.
  if [[ -n "${netvm}" ]]; then
      _message "Getting network from $netvm"
      qvm-prefs "$name" netvm "$netvm"
  fi

  # If the user wants this VM to be the default NetVM for all clients
  # like browsers, messaging VMs, etc.
  if [[ ${args[--set-default]} -eq 1 ]]; then
      echo "$name" > "${IDENTITY_DIR}/net_vm"

      _message "Setting '$name' as default NetVM for all client machines"

      # Here, find all existing client VMs (not gateways)

      # and change their netVMs to this one.
      local clients=($(_identity_client_vms))
      for client in "${clients[@]}"; do
          if [[ -n "$client" ]]; then
              _verbose "Changing $client netVM"
              qvm-prefs "$client" netvm "$name"
          fi
      done
  fi

  # Client VPN Configurations
  if [[ "${args[--choose]}" -eq 1 ]]; then
      # If we are asked to choose an existing configuration in the VM
      _qvrun "$name" /usr/local/bin/setup_VPN

  elif [[ -n "${args[--config-in]}" ]]; then
      # Or if we are asked to browse one or more configuration files in another VM.
      import_vpn_configs "$name" "$config_vm" "$client_conf_path"
  fi

}

# :command.function
risk_vpn_start_command() {
  # src/vpn_start_command.sh

  local name="${args[vm]}"

  _message "Starting gateway $name in the background"
  start_vm "$name"
  _catch "Failed to start $name"
  _message "Started VM $name"

}

# :command.function
risk_vpn_stop_command() {
  # src/vpn_stop_command.sh

  local name="${args[vm]}"

  _message "Shutting down gateway $name"
  shutdown_vm "$name"
  _catch "Failed to shutdown $name"
  _message "Shut down $name"

}

# :command.function
risk_vpn_enable_command() {
  # src/vpn_enable_command.sh

  _set_identity

  local name autostart_vms already_enabled

  name="${args[vm]}"
  autostart_vms=($(_identity_autostart_vms))

  # Check if the VM is already marked autostart
  for proxy in "${autostart_vms[@]}" ; do
      if [[ $proxy == "$name" ]]; then
          already_enabled=true
      fi
  done

  if [[ ! $already_enabled ]]; then
      _message "Enabling VM ${name} to autostart"
      echo "$name" >> "${IDENTITY_DIR}/autostart_vms"
  else
      _message "VM ${name} is already enabled"
  fi

}

# :command.function
risk_vpn_disable_command() {
  # src/vpn_disable_command.sh

  _set_identity

  local name="${args[vm]}"

  _message "Disabling VM $name"
  sed -i /"$name"/d "${IDENTITY_DIR}/autostart_vms"

}

# :command.function
risk_vpn_delete_command() {
  # src/vpn_delete_command.sh

  _set_identity

  local name found proxies

  name="${args[vm]}"

  # Check that the selected VM is indeed one of the identity
  # proxy VMs, so that we don't accidentally delete another one.
  proxies=($(_identity_proxies))
  for proxy in "${proxies[@]}" ; do
      if [[ $proxy == "$name" ]]; then
          found=true
      fi
  done

  if [[ ! $found ]]; then
      _message "VM $name is not listed as a VPN gateway. Aborting."
      exit 1
  fi

  _message "Deleting gateway VM $name"

  # If the VPN was the default NetVM for the identity,
  # update the NetVM to Whonix.
  netvm="$(cat "${IDENTITY_DIR}/net_vm")"
  if [[ $netvm == "$name" ]]; then
      _warning "Gateway $name is the default NetVM for identity clients !"

      # Check if we have a TOR gateway
      local tor_gw

      if [[ -n $tor_gw ]]; then
          _message -n "Updating the default identity NetVM to $tor_gw"
      else
          _message -n "The identity has no default NetVM anymore, please set it."
      fi
  fi

  # Check if there are some existing VMs that use this gateway as NetVM,
  # and change their netVM to None: this is unpractical, especially for
  # those that might be up, but it's better than assigning a new netVM
  # despite this presenting a security risk.

  # Delete without asking to confirm
  echo "y" | _run qvm-remove "$name"
  _catch "Failed to delete (fully or partially) VM $name"

  # Remove from VMs marked autostart
  sed -i /"$name"/d "${IDENTITY_DIR}/autostart_vms"
  # And remove from proxy VMs

  sed -i /"$name"/d "${IDENTITY_DIR}/proxy_vms"

  _message "Deleted $name"

}

# :command.function
risk_config_set_command() {
  # src/config_set_command.sh

  local key value

  key="${args[key]}"
  value="${args[value]}"

  config_set "$key" "$value"

}

# :command.function
risk_config_get_command() {
  # src/config_get_command.sh

  local key

  key="${args[key]}"

  config_get "$key"

}

# :command.function
risk_config_unset_command() {
  # src/config_unset_command.sh

  local key

  key="${args[key]}"

  config_set "$key" ""

}

# :command.function
risk_config_list_command() {
  # src/config_list_command.sh
  config_show

}

# :command.function
risk_config_keys_command() {
  # src/config_keys_command.sh
  config_keys

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    risk_usage
    exit
    ;;

  esac

  # :command.environment_variables_filter
  export RISK_VPN_TEMPLATE="${RISK_VPN_TEMPLATE:-sys-vpn}"
  export RISK_DEFAULT_NETVM="${RISK_DEFAULT_NETVM:-sys-firewall}"
  export VAULT_VM="${VAULT_VM:-vault}"

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  hush )
    action="hush"
    shift
    risk_hush_parse_requirements "$@"
    shift $#
    ;;

  backup )
    action="backup"
    shift
    risk_backup_parse_requirements "$@"
    shift $#
    ;;

  identity )
    action="identity"
    shift
    risk_identity_parse_requirements "$@"
    shift $#
    ;;

  vpn )
    action="vpn"
    shift
    risk_vpn_parse_requirements "$@"
    shift $#
    ;;

  config )
    action="config"
    shift
    risk_config_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_hush_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  attach )
    action="attach"
    shift
    risk_hush_attach_parse_requirements "$@"
    shift $#
    ;;

  detach )
    action="detach"
    shift
    risk_hush_detach_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_hush_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_attach_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_hush_attach_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --mount | -m )

      # :flag.case_no_arg
      args[--mount]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[device]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_device "$1") ]]; then
          printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")"
          exit 1
        fi

        args[device]=$1
        shift
      elif [[ -z ${args[vault_vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_valid_vaultvm "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")"
          exit 1
        fi

        args[vault_vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
risk_hush_detach_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_hush_detach_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="hush detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_backup_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  attach )
    action="attach"
    shift
    risk_backup_attach_parse_requirements "$@"
    shift $#
    ;;

  detach )
    action="detach"
    shift
    risk_backup_detach_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_backup_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_attach_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_backup_attach_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="backup attach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[device]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_device "$1") ]]; then
          printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_device "$1")"
          exit 1
        fi

        args[device]=$1
        shift
      elif [[ -z ${args[vault_vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_valid_vaultvm "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VAULT_VM" "$(validate_valid_vaultvm "$1")"
          exit 1
        fi

        args[vault_vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
risk_backup_detach_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_backup_detach_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="backup detach"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  create )
    action="create"
    shift
    risk_identity_create_parse_requirements "$@"
    shift $#
    ;;

  delete )
    action="delete"
    shift
    risk_identity_delete_parse_requirements "$@"
    shift $#
    ;;

  open )
    action="open"
    shift
    risk_identity_open_parse_requirements "$@"
    shift $#
    ;;

  close )
    action="close"
    shift
    risk_identity_close_parse_requirements "$@"
    shift $#
    ;;

  start )
    action="start"
    shift
    risk_identity_start_parse_requirements "$@"
    shift $#
    ;;

  stop )
    action="stop"
    shift
    risk_identity_stop_parse_requirements "$@"
    shift $#
    ;;

  current )
    action="current"
    shift
    risk_identity_current_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_identity_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_create_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_create_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --name | -N )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name, -N NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --label | -L )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--label]="$2"
        shift
        shift
      else
        printf "%s\n" "--label requires an argument: --label, -L COLOR"
        exit 1
      fi
      ;;

    # :flag.case
    --no-gw | -G )
      # :flag.conflicts
      if [[ -n "${args[--clone-gw-from]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-gw-from"
        exit 1
      fi

      # :flag.case_no_arg
      args[--no-gw]=1
      shift
      ;;

    # :flag.case
    --clone-gw-from )
      # :flag.conflicts
      if [[ -n "${args[--no-gw]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-gw"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--clone-gw-from]="$2"
        shift
        shift
      else
        printf "%s\n" "--clone-gw-from requires an argument: --clone-gw-from TOR_GW"
        exit 1
      fi
      ;;

    # :flag.case
    --no-vpn | -V )
      # :flag.conflicts
      if [[ -n "${args[--clone-vpn-from]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-vpn-from"
        exit 1
      fi

      # :flag.case_no_arg
      args[--no-vpn]=1
      shift
      ;;

    # :flag.case
    --clone-vpn-from )
      # :flag.conflicts
      if [[ -n "${args[--no-vpn]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-vpn"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--clone-vpn-from]="$2"
        shift
        shift
      else
        printf "%s\n" "--clone-vpn-from requires an argument: --clone-vpn-from VPN_GW"
        exit 1
      fi
      ;;

    # :flag.case
    --no-messenger | -M )
      # :flag.conflicts
      if [[ -n "${args[--clone-messenger-from]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--clone-messenger-from"
        exit 1
      fi

      # :flag.case_no_arg
      args[--no-messenger]=1
      shift
      ;;

    # :flag.case
    --clone-messenger-from )
      # :flag.conflicts
      if [[ -n "${args[--no-messenger]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-messenger"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--clone-messenger-from]="$2"
        shift
        shift
      else
        printf "%s\n" "--clone-messenger-from requires an argument: --clone-messenger-from MESSENGER_VM"
        exit 1
      fi
      ;;

    # :flag.case
    --clone-web-from )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--clone-web-from]="$2"
        shift
        shift
      else
        printf "%s\n" "--clone-web-from requires an argument: --clone-web-from WEB_VM"
        exit 1
      fi
      ;;

    # :flag.case
    --clone-split-from )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--clone-split-from]="$2"
        shift
        shift
      else
        printf "%s\n" "--clone-split-from requires an argument: --clone-split-from SPLIT_BROWSER_VM"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[identity]+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity create IDENTITY [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_delete_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_delete_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[identity]+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity delete IDENTITY [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_open_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_open_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[identity]+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity open IDENTITY [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_close_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_close_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_start_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_start_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[identity]+x} ]]; then

        args[identity]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[identity]+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risk identity start IDENTITY [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_identity_stop_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_stop_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_identity_current_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_identity_current_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="identity current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  create )
    action="create"
    shift
    risk_vpn_create_parse_requirements "$@"
    shift $#
    ;;

  setup )
    action="setup"
    shift
    risk_vpn_setup_parse_requirements "$@"
    shift $#
    ;;

  start )
    action="start"
    shift
    risk_vpn_start_parse_requirements "$@"
    shift $#
    ;;

  stop )
    action="stop"
    shift
    risk_vpn_stop_parse_requirements "$@"
    shift $#
    ;;

  enable )
    action="enable"
    shift
    risk_vpn_enable_parse_requirements "$@"
    shift $#
    ;;

  disable )
    action="disable"
    shift
    risk_vpn_disable_parse_requirements "$@"
    shift $#
    ;;

  delete )
    action="delete"
    shift
    risk_vpn_delete_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_vpn_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_create_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_create_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --name | -N )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name, -N NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --label | -L )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--label]="$2"
        shift
        shift
      else
        printf "%s\n" "--label requires an argument: --label, -L COLOR"
        exit 1
      fi
      ;;

    # :flag.case
    --enable | -E )

      # :flag.case_no_arg
      args[--enable]=1
      shift
      ;;

    # :flag.case
    --template | -T )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--template]="$2"
        shift
        shift
      else
        printf "%s\n" "--template requires an argument: --template, -T TEMPLATE"
        exit 1
      fi
      ;;

    # :flag.case
    --clone | -c )

      # :flag.case_no_arg
      args[--clone]=1
      shift
      ;;

    # :flag.case
    --from | -f )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--from]="$2"
        shift
        shift
      else
        printf "%s\n" "--from requires an argument: --from, -f VPN_GW"
        exit 1
      fi
      ;;

    # :flag.case
    --set-default )

      # :flag.case_no_arg
      args[--set-default]=1
      shift
      ;;

    # :flag.case
    --config-in )
      # :flag.conflicts
      if [[ -n "${args[--choose]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--config-in]="$2"
        shift
        shift
      else
        printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM"
        exit 1
      fi
      ;;

    # :flag.case
    --netvm | -n )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--netvm]="$2"
        shift
        shift
      else
        printf "%s\n" "--netvm requires an argument: --netvm, -n VM"
        exit 1
      fi
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

}

# :command.parse_requirements
risk_vpn_setup_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_setup_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    # :flag.case
    --config-in )
      # :flag.conflicts
      if [[ -n "${args[--choose]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--choose"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--config-in]="$2"
        shift
        shift
      else
        printf "%s\n" "--config-in requires an argument: --config-in CONFIG_VM"
        exit 1
      fi
      ;;

    # :flag.case
    --set-default )

      # :flag.case_no_arg
      args[--set-default]=1
      shift
      ;;

    # :flag.case
    --netvm | -n )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--netvm]="$2"
        shift
        shift
      else
        printf "%s\n" "--netvm requires an argument: --netvm, -n VM"
        exit 1
      fi
      ;;

    # :flag.case
    --choose )
      # :flag.conflicts
      if [[ -n "${args[--config-in]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--config-in"
        exit 1
      fi

      # :flag.case_no_arg
      args[--choose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn setup VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_start_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_start_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn start"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn start VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_stop_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_stop_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn stop VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_enable_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_enable_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn enable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn enable VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_disable_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_disable_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn disable"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn disable VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_vpn_delete_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_vpn_delete_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="vpn delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --verbose | -v )

      # :flag.case_no_arg
      args[--verbose]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[vm]+x} ]]; then
        # :argument.validations
        if [[ -n $(validate_vm_exists "$1") ]]; then
          printf "validation error in %s:\n%s\n" "VM" "$(validate_vm_exists "$1")"
          exit 1
        fi

        args[vm]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[vm]+x} ]]; then
    printf "missing required argument: VM\nusage: risk vpn delete VM [options]\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_config_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  set )
    action="set"
    shift
    risk_config_set_parse_requirements "$@"
    shift $#
    ;;

  get )
    action="get"
    shift
    risk_config_get_parse_requirements "$@"
    shift $#
    ;;

  unset )
    action="unset"
    shift
    risk_config_unset_parse_requirements "$@"
    shift $#
    ;;

  list )
    action="list"
    shift
    risk_config_list_parse_requirements "$@"
    shift $#
    ;;

  keys )
    action="keys"
    shift
    risk_config_keys_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    risk_config_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_set_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      elif [[ -z ${args[value]+x} ]]; then

        args[value]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config set KEY VALUE\n"
    exit 1
  fi
  if [[ -z ${args[value]+x} ]]; then
    printf "missing required argument: VALUE\nusage: risk config set KEY VALUE\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_get_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config get KEY\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_config_unset_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_unset_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      if [[ -z ${args[key]+x} ]]; then

        args[key]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi

      ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args[key]+x} ]]; then
    printf "missing required argument: KEY\nusage: risk config unset KEY\n"
    exit 1
  fi

}

# :command.parse_requirements
risk_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_list_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
risk_config_keys_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    risk_config_keys_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="config keys"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  

  # src/initialize.sh

  # Connected terminal
  typeset -H _TTY
  GPG_TTY=$(tty)  # Needed for GPG operations
  export GPG_TTY

  # Remove verbose errors when * don't yield any match in ZSH
  setopt +o nomatch

  # Working state variables
  typeset -r IDENTITY            # The identity to use for this single risk execution
  typeset -g IDENTITY_DIR        # The directory where to store identity settings

  # Default templates and VMs to use

  typeset -rg WHONIX_GW_TEMPLATE="whonix-gw-16"
  typeset -rg WHONIX_WS_TEMPLATE="whonix-ws-16"

  # Working state and configurations
  typeset -rg RISK_DIR="${HOME}/.risk"                         # Directory where risk stores its state
  typeset -rg RISK_IDENTITIES_DIR="${RISK_DIR}/identities"     # Idendities store their settings here
  typeset -rg RISK_IDENTITY_FILE="${RISK_DIR}/.identity"

  #----------------------------#

  # Don't run as root
  if [[ $EUID -eq 0 ]]; then
     echo "This script must be run as user"
     exit 2
  fi

  # Use colors unless told not to
  { ! option_is_set --no-color } && { autoload -Uz colors && colors }

  #----------------------------#

  # Create the risk directory if needed
  [[ -e $RISK_DIR ]] || { mkdir -p $RISK_DIR && _message "Creating RISK directory in $RISK_DIR" }
  [[ -e $RISK_IDENTITIES_DIR ]] || mkdir -p $RISK_IDENTITIES_DIR

  # Write the default configuration if it does not exist.
  config_init

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "hush" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_hush_usage
    else
      risk_hush_command
    fi

  elif [[ $action == "hush attach" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_hush_attach_usage
    else
      risk_hush_attach_command
    fi

  elif [[ $action == "hush detach" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_hush_detach_usage
    else
      risk_hush_detach_command
    fi

  elif [[ $action == "backup" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_backup_usage
    else
      risk_backup_command
    fi

  elif [[ $action == "backup attach" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_backup_attach_usage
    else
      risk_backup_attach_command
    fi

  elif [[ $action == "backup detach" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_backup_detach_usage
    else
      risk_backup_detach_command
    fi

  elif [[ $action == "identity" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_usage
    else
      risk_identity_command
    fi

  elif [[ $action == "identity create" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_create_usage
    else
      risk_identity_create_command
    fi

  elif [[ $action == "identity delete" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_delete_usage
    else
      risk_identity_delete_command
    fi

  elif [[ $action == "identity open" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_open_usage
    else
      risk_identity_open_command
    fi

  elif [[ $action == "identity close" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_close_usage
    else
      risk_identity_close_command
    fi

  elif [[ $action == "identity start" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_start_usage
    else
      risk_identity_start_command
    fi

  elif [[ $action == "identity stop" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_stop_usage
    else
      risk_identity_stop_command
    fi

  elif [[ $action == "identity current" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_identity_current_usage
    else
      risk_identity_current_command
    fi

  elif [[ $action == "vpn" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_usage
    else
      risk_vpn_command
    fi

  elif [[ $action == "vpn create" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_create_usage
    else
      risk_vpn_create_command
    fi

  elif [[ $action == "vpn setup" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_setup_usage
    else
      risk_vpn_setup_command
    fi

  elif [[ $action == "vpn start" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_start_usage
    else
      risk_vpn_start_command
    fi

  elif [[ $action == "vpn stop" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_stop_usage
    else
      risk_vpn_stop_command
    fi

  elif [[ $action == "vpn enable" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_enable_usage
    else
      risk_vpn_enable_command
    fi

  elif [[ $action == "vpn disable" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_disable_usage
    else
      risk_vpn_disable_command
    fi

  elif [[ $action == "vpn delete" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_vpn_delete_usage
    else
      risk_vpn_delete_command
    fi

  elif [[ $action == "config" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_usage
    else
      risk_config_command
    fi

  elif [[ $action == "config set" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_set_usage
    else
      risk_config_set_command
    fi

  elif [[ $action == "config get" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_get_usage
    else
      risk_config_get_command
    fi

  elif [[ $action == "config unset" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_unset_usage
    else
      risk_config_unset_command
    fi

  elif [[ $action == "config list" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_list_usage
    else
      risk_config_list_command
    fi

  elif [[ $action == "config keys" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      risk_config_keys_usage
    else
      risk_config_keys_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
