#compdef _risk risk 
#autoload

# Entrypoint ================================================================================== 

_risk () 
{
    local cmd
    if (( CURRENT > 2 )); then
        cmd=${words[2]}
        # Set the context for the subcommand
        curcontext="${curcontext%:*:*}:risk-$cmd"
        # Narrow the range of words we are looking at to exclude `risk`
        (( CURRENT-- ))
        shift words
        # Run the completion for the subcommand
        case "${cmd}" in
            (hush) _hush ;;
            (backup) _backup ;;
            (identity) _identity ;;
            (vpn) _vpn ;;
        esac
    else
        local -a subcmds
        subcmds=(
            'hush:Attach or detach the hush partition to vault'
            'backup:Attach or detach a backup partition to vault'
            'identity:Create, manage and use identities and/or use their machines'
            'vpn:Create, configure, manage and use VPN gateways for an identity'
            'slam:Close identity and/or associated stores in the vault only, and detach hush/backup'
        )

        _describe -t commands 'commands' subcmds
    fi
}

# Subcomands ==================================================================================

# Completes the commands for hush, without parameters
_hush_commands () 
{
    local -a hushcmds 
    hushcmds=(
        'attach:Attach the hush drive to vault'
        'detach:Detach the hush drive from vault'
    )

    _describe -t commands 'hush commands' hushcmds && ret=0
}

# Completion dispatcher for hush subcommand
_hush ()
{
    local ret=1
    local line state

    # Register subcommands and argument patterns
    _arguments -C \
        "${_flags_base[@]}" \
        "1: :_hush_commands" \
        "*::arg:->args" \
        && ret=0

    # Arguments completion
    case $state in
        args)
            case $line[1] in
            attach)
                _arguments \
                    "${_flags_base[@]}" \
                    '1:hush block device:_block_devices' \
                    '2:vault VM:($(_known_vms))' \
                    && ret=0
                ;;
            *)
                _arguments \
                    "${_flags_base[@]}" \
                    && ret=0
                ;;
            esac
    esac
}

# Completes the commands for backup, without parameters
_backup_commands () 
{
    local -a subcmds 
    subcmds=(
        'attach:Attach a backup drive to vault'
        'detach:Detach the backup drive from vault'
    )

    _describe -t commands 'backup commands' subcmds && ret=0
}

# Completion dispatcher for backup subcommand
_backup ()
{
    local ret=1
    local line state

    # Register subcommands and argument patterns
    _arguments -C \
        "1: :_backup_commands" \
        "*::arg:->args" \
        && ret=0

    # Arguments completion
    case $state in
        args)
            case $line[1] in
            attach)
                _arguments \
                    "${_flags_base[@]}" \
                    '1:backup block device:_block_devices' \
                    '2:vault VM:($(_known_vms))' \
                    && ret=0
                ;;
            *)
                _arguments \
                    "${_flags_base[@]}" \
                    && ret=0
                ;;
            esac
    esac
}

# Subcommands of the identity command
_identity_commands ()
{
    local -a subcmds 
    subcmds=(
        'open:Open an identity and its associated builtin stores in the vault'
        'create:Create associated VMs for an identity (joe-gw, joe-vpn, joe-msg, joe-web, etc)'
        'delete:Destroys an identity and all its associated machines and data'
        'close:Simply open the identity store in the vault'
        'start:Start the identity in the vault and all of its enabled VMs'
        'stop:Stops all machines belonging to an identity, and close its vault if active.'
    )
    _describe -t commands 'identity commands' subcmds && ret=0
}

# Completion dispatcher for identity command
_identity ()
{
    local line state

    _arguments -C \
        "1: :_identity_commands" \
        "*::arg:->args"

    # Arguments completion
    case $state in
        args)
            case $line[1] in
            create)
                _identity_create
                ;;
            start|open|delete)
                _arguments \
                    "${_flags_base[@]}" \
                    '1:identity name:' \
                    && ret=0
                ;;
            *)
                _arguments \
                    "${_flags_base[@]}" \
                    && ret=0
                ;;
            esac
    esac
}

# Completions for the identity create command
_identity_create ()
{
    local line state

    _arguments -C \
        '1:identity name:->name' \
        "2:email recipient:->recipient" \
        "3:key expiry:->duration" \
        "${_flags_base[@]}" \
        "${_flags_init_base[@]}" \
        "${_flags_init_vpn[@]}" \
        "${_flags_init_tor[@]}" \
        "${_flags_network_opts[@]}" \
        "${_flags_init_web[@]}" \
        "${_flags_init_messenger[@]}" \
        && ret=0

    # Indications for the create identity command
    case "$state" in
        name)
            _message "quoted string of the name, if spaces"
            ;;
        recipient)
            _message "mail address recipient to use for GPG" 
            ;;
        duration)
            _message "quoted, human readable expiry duration for GPG keys" 
            ;;
    esac
}

# Subcommands of the vpn command
_vpn_commands ()
{
    local -a subcmds 
    subcmds=(
        'create:Create VPN gateway from a template, or by cloning an existing one'
        'setup:Manage, import network configurations and run associated setup wizards'
        'enable:Automatically start a VPN gateway when starting the identity'
        'start:Start a VPN gateway in the background'
        'stop:Stop a VPN gateway'
        'delete:Delete a VPN gateway'
    )
    _describe -t commands 'vpn commands' subcmds && ret=0
}

# Completion dispatcher for vpn command
_vpn ()
{
    local ret=1
    local line state

    _arguments -C \
        "1: :_vpn_commands" \
        "*::arg:->args" \
        && ret=0

    # Arguments completion
    case $state in
        args)
            case $line[1] in
            create)
                _arguments -C \
                    "${_flags_base[@]}" \
                    "${_flags_init_base[@]}" \
                    "${_flags_init_vpn[@]}" \
                    "${_flags_network_opts[@]}" \
                    '1::identity name (optional if active):' \
                    && ret=0
                ;;
            start|stop|delete|enable)
                _arguments \
                    "${_flags_base[@]}" \
                    '1:VPN gateway name:' \
                    && ret=0
                ;;
            setup)
                _arguments \
                    "${_flags_base[@]}" \
                    {-c,--config-in}'[VM in which to browse for VPN configuration(s)]:VM containing configs:_known_vms' \
                    && ret=0
                ;;
            esac
    esac
}

# Flags =======================================================================================

# Flags that are present on all commands
_flags_base=(
    '(-v --verbose)'{-v,--verbose}'[Enable verbose logging]'
    '(- : *)'{-h,--help}'[Print help for the command]'
)

## Init command flags
_flags_init_base=(
    '(-N --name)'{-N,--name}'[Use a different name for naming identity VMs]' 
    '(-L --label)'{-L,--label}'[Specify a label color to be used for ALL subsequently created VMs]' 
)

_flags_init_vpn=(
    '(--clone-vpn-from --vpn-over-tor -V --no-vpn)'{-V,--no-vpn}'[Do not create a VPN gateway]' 
    '(-V --no-vpn --clone-vpn-from)'--clone-vpn-from'[Instead of creating the VPN gateway from a template, clone an existing VPN AppVM]:VM:_known_vms'
)

_flags_init_tor=(
    '(--clone-gw-from --vpn-over-tor -G --no-gw)'{-G,--no-gw}'[Do not create a Whonix TOR gateway]' 
    '(-G --no-gw --clone-gw-from)'--clone-gw-from"[Instead of creating the TOR gateway from a template, clone an existing TOR AppVM]:VM:_known_vms"
)

_flags_network_opts=(
    '(-V --no-vpn -G --no-gw)'--vpn-over-tor'[Instead of routing TOR traffic through the VPN, route the VPN traffic through TOR]' 
)

_flags_init_messenger=(
    '(--clone-messenger-from -M --no-messenger)'{-M,--no-messenger}'[Do not create a Messenger VM (for Signal and other message services)]'
    '(-M --no-messenger --clone-messenger-from)'--clone-messenger-from'[Instead of creating the Messenger VM from a template, clone an existing Messenger AppVM]:VM:_known_vms'
)

_flags_init_web=(
    '--clone-web-from[Instead of creating the Web browsing VM from a template, clone an existing browser AppVM]:VM:_known_vms'
    '--clone-split-from[Instead of creating the split-browser VM from a template, clone an existing one]:VM:_known_vms'
)

# Command arguments ===========================================================================

# Completes qubes-style block devices
_block_devices () 
{
    local -a blocks

    local -a devices=("${(@f)$(qvm-block list)}")
    for device in "${devices[@]}"; do
        id=$(echo $device | awk 'END {print $1}' | sed 's/\:/\\:/g') 
        desc=$(echo $device | awk 'END {print $2}'| sed 's/\:/\\:/g') 

        blocks+=("$id:${desc}")
    done

    _describe -t arguments 'block devices' blocks && ret=0
}

_known_vms ()
{
    local ret=
    # VMS
    local VM_COMPLETIONS=()

    while IFS= read -r VM_NAME ; do
        VM_COMPLETIONS+=("${VM_NAME}")
    done < <(qvm-ls --raw-list | sort)

    _arguments -C "*:VMs:($VM_COMPLETIONS)" && ret=0
}


# don't run the completion function when being source-ed or eval-ed
if [ "$funcstack[1]" = "_risk" ]; then
        _risk
fi
